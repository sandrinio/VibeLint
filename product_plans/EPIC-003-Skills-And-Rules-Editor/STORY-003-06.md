---
id: STORY-003-06
parent_epic: EPIC-003
status: Done
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-003-06: Commands CRUD API

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** Fastify REST API routes for listing, reading, creating, updating, deleting, and resetting slash commands per repository,
**So that** the frontend Rules Editor can manage both built-in and custom slash commands for any connected repo.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/server/api/commands.ts` as a Fastify route plugin.
- **Requirement 2**: `GET /api/repos/:repoId/commands` — list all commands (defaults + custom) for a repo, returning an array of `{ name, content, isDefault, isModified, description }`.
- **Requirement 3**: `GET /api/repos/:repoId/commands/:name` — get a single command's content. Check for custom override first; fall back to default template.
- **Requirement 4**: `PUT /api/repos/:repoId/commands/:name` — save custom command content. Store in `config` table with key pattern `commands:{repoId}:{name}`.
- **Requirement 5**: `POST /api/repos/:repoId/commands` — create a new custom command (requires `name` and `content`). Must not collide with an existing default or custom command name.
- **Requirement 6**: `DELETE /api/repos/:repoId/commands/:name` — delete a custom command. Returns 400 if attempting to delete a built-in default.
- **Requirement 7**: `POST /api/repos/:repoId/commands/:name/reset` — reset a command to its default content by deleting the custom override. Returns 404 if the command has no built-in default.
- **Requirement 8**: Default commands are loaded from `templates/commands/claude-code/` for Claude Code repos, or `templates/commands/generic/` for other platforms (based on the repo's `platform` field).
- **Requirement 9**: Extract a short description from the first heading of each command template (e.g., `# Code Review` becomes `description: "Code Review"`) to display in the command list.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Commands CRUD API

  Background:
    Given a repo "repo-1" exists with platform "claude-code"
    And default command templates exist in templates/commands/claude-code/

  Scenario: List commands returns defaults plus custom
    Given no custom commands exist for "repo-1"
    When I GET /api/repos/repo-1/commands
    Then the response status is 200
    And the body is an array with entries for review, check, health, vdoc-init, vdoc-update
    And each has isDefault true and isModified false
    And each has a description extracted from the first heading

  Scenario: List commands shows modified indicator
    Given a custom override exists for "review.md" in "repo-1"
    When I GET /api/repos/repo-1/commands
    Then the "review.md" entry has isModified true

  Scenario: Get a default command
    When I GET /api/repos/repo-1/commands/review.md
    Then the response status is 200
    And the body contains the default review command content
    And isDefault is true

  Scenario: Get a custom-overridden command
    Given a custom override with content "custom review" exists for "review.md" in "repo-1"
    When I GET /api/repos/repo-1/commands/review.md
    Then the body content is "custom review"
    And isDefault is false

  Scenario: Save custom command content
    When I PUT /api/repos/repo-1/commands/review.md with body { "content": "updated review" }
    Then the response status is 200
    And the config table has key "commands:repo-1:review.md"

  Scenario: Create a new custom command
    When I POST /api/repos/repo-1/commands with body { "name": "deploy.md", "content": "deploy steps" }
    Then the response status is 201
    And the config table has key "commands:repo-1:deploy.md"

  Scenario: Create fails for duplicate name
    Given a custom command "deploy.md" exists for "repo-1"
    When I POST /api/repos/repo-1/commands with body { "name": "deploy.md", "content": "content" }
    Then the response status is 409

  Scenario: Delete a custom command
    Given a custom command "deploy.md" exists for "repo-1"
    When I DELETE /api/repos/repo-1/commands/deploy.md
    Then the response status is 200
    And the config table no longer has key "commands:repo-1:deploy.md"

  Scenario: Cannot delete a built-in default
    When I DELETE /api/repos/repo-1/commands/review.md
    Then the response status is 400

  Scenario: Reset command to default
    Given a custom override exists for "review.md" in "repo-1"
    When I POST /api/repos/repo-1/commands/review.md/reset
    Then the response status is 200
    And GET returns the default template content

  Scenario: Non-existent repo returns 404
    When I GET /api/repos/nonexistent/commands
    Then the response status is 404
```

### 2.2 Verification Steps
- [ ] `GET /api/repos/:repoId/commands` returns default commands with correct `isDefault`/`isModified` flags.
- [ ] Custom overrides appear with `isModified: true`.
- [ ] `GET /api/repos/:repoId/commands/:name` returns custom content when override exists, default otherwise.
- [ ] `PUT` saves to `config` table with key `commands:{repoId}:{name}`.
- [ ] `POST` creates new custom commands and rejects duplicates (409).
- [ ] `DELETE` removes custom commands and rejects built-in deletions (400).
- [ ] `POST .../reset` removes override and returns default content.
- [ ] Commands for non-Claude Code repos load from `templates/commands/generic/`.
- [ ] Description is extracted from the first `# ` heading of each command template.
- [ ] All routes return 404 for non-existent repos.
- [ ] TypeScript compiles with no errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/api/commands.ts` (create)
- **Related Files**:
  - `src/server/templates/loader.ts` (STORY-003-01, provides `loadTemplate`, `listTemplates`)
  - `src/server/db/queries.ts` (existing, database operations)
  - `src/server/db/schema.ts` (existing, `repos` and `config` tables)
  - `src/server/index.ts` (existing, register route plugin)
- **New Files Needed**:
  - `src/server/api/commands.ts`

### 3.2 Technical Logic

**Step 1: Define types**

```typescript
// src/server/api/commands.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { loadTemplate, listTemplates, TemplateNotFoundError } from '../templates/loader.js';

/** Response shape for a single command */
interface CommandResponse {
  name: string;
  content: string;
  /** Short description extracted from the first heading */
  description: string;
  isDefault: boolean;
  isModified: boolean;
}

interface CreateCommandBody {
  name: string;
  content: string;
}

interface UpdateCommandBody {
  content: string;
}

interface RepoParams { repoId: string; }
interface CommandParams extends RepoParams { name: string; }

/** Map platform to command template category */
const PLATFORM_COMMAND_CATEGORY: Record<string, string> = {
  'claude-code': 'commands/claude-code',
  'cursor':      'commands/generic',
  'windsurf':    'commands/generic',
  'gemini-cli':  'commands/generic',
  'antigravity': 'commands/generic',
  'other':       'commands/generic',
};
```

**Step 2: Helper to extract description from content**

```typescript
/**
 * Extract a short description from markdown content.
 * Looks for the first "# Heading" and returns the heading text.
 * Falls back to the first non-empty line, or the filename without extension.
 */
function extractDescription(content: string, fallbackName: string): string {
  const lines = content.split('\n');
  for (const line of lines) {
    const match = line.match(/^#\s+(.+)$/);
    if (match) return match[1].trim();
  }
  // Fallback: filename without extension, capitalize
  const baseName = fallbackName.replace(/\.md$/, '');
  return baseName.charAt(0).toUpperCase() + baseName.slice(1);
}
```

**Step 3: Implement the Fastify plugin**

```typescript
export default async function commandRoutes(
  fastify: FastifyInstance,
  _opts: FastifyPluginOptions,
): Promise<void> {

  // Helper: get repo
  function getRepo(repoId: string): { id: string; platform: string } | undefined {
    return fastify.db
      .prepare('SELECT id, platform FROM repos WHERE id = ?')
      .get(repoId) as { id: string; platform: string } | undefined;
  }

  // Helper: config key
  function cmdKey(repoId: string, name: string): string {
    return `commands:${repoId}:${name}`;
  }

  // Helper: get custom command
  function getCustomCommand(repoId: string, name: string): string | null {
    const row = fastify.db
      .prepare('SELECT value FROM config WHERE key = ?')
      .get(cmdKey(repoId, name)) as { value: string } | undefined;
    return row ? JSON.parse(row.value).content : null;
  }

  // Helper: list all custom commands for a repo
  function listCustomCommands(repoId: string): Map<string, string> {
    const prefix = `commands:${repoId}:`;
    const rows = fastify.db
      .prepare('SELECT key, value FROM config WHERE key LIKE ?')
      .all(`${prefix}%`) as { key: string; value: string }[];
    const map = new Map<string, string>();
    for (const row of rows) {
      const name = row.key.slice(prefix.length);
      map.set(name, JSON.parse(row.value).content);
    }
    return map;
  }

  // Helper: get command template category for a repo
  function getCommandCategory(platform: string): string {
    return PLATFORM_COMMAND_CATEGORY[platform] ?? 'commands/generic';
  }

  // Helper: check if command is a built-in default for the given platform
  function isBuiltInCommand(platform: string, name: string): boolean {
    const category = getCommandCategory(platform);
    try {
      loadTemplate(category, name);
      return true;
    } catch {
      return false;
    }
  }

  // ── GET /api/repos/:repoId/commands ──
  fastify.get<{ Params: RepoParams }>(
    '/api/repos/:repoId/commands',
    async (request, reply) => {
      const { repoId } = request.params;
      const repo = getRepo(repoId);
      if (!repo) return reply.status(404).send({ error: 'Repo not found' });

      const category = getCommandCategory(repo.platform);
      const defaults = listTemplates(category);
      const customs = listCustomCommands(repoId);

      const commands: CommandResponse[] = [];

      // Add defaults (with override check)
      for (const tpl of defaults) {
        const customContent = customs.get(tpl.name);
        const content = customContent ?? tpl.content;
        commands.push({
          name: tpl.name,
          content,
          description: extractDescription(content, tpl.name),
          isDefault: !customContent,
          isModified: !!customContent,
        });
        customs.delete(tpl.name);
      }

      // Add pure custom commands
      for (const [name, content] of customs) {
        commands.push({
          name,
          content,
          description: extractDescription(content, name),
          isDefault: false,
          isModified: false,
        });
      }

      return reply.send(commands);
    },
  );

  // ── GET /api/repos/:repoId/commands/:name ──
  fastify.get<{ Params: CommandParams }>(
    '/api/repos/:repoId/commands/:name',
    async (request, reply) => {
      const { repoId, name } = request.params;
      const repo = getRepo(repoId);
      if (!repo) return reply.status(404).send({ error: 'Repo not found' });

      // Check custom first
      const customContent = getCustomCommand(repoId, name);
      if (customContent !== null) {
        return reply.send({
          name,
          content: customContent,
          description: extractDescription(customContent, name),
          isDefault: false,
          isModified: true,
        });
      }

      // Fall back to default
      const category = getCommandCategory(repo.platform);
      try {
        const tpl = loadTemplate(category, name);
        return reply.send({
          name: tpl.name,
          content: tpl.content,
          description: extractDescription(tpl.content, tpl.name),
          isDefault: true,
          isModified: false,
        });
      } catch (err) {
        if (err instanceof TemplateNotFoundError) {
          return reply.status(404).send({ error: `Command not found: ${name}` });
        }
        throw err;
      }
    },
  );

  // ── PUT /api/repos/:repoId/commands/:name ──
  fastify.put<{ Params: CommandParams; Body: UpdateCommandBody }>(
    '/api/repos/:repoId/commands/:name',
    async (request, reply) => {
      const { repoId, name } = request.params;
      const { content } = request.body;
      const repo = getRepo(repoId);
      if (!repo) return reply.status(404).send({ error: 'Repo not found' });

      fastify.db
        .prepare('INSERT OR REPLACE INTO config (key, value) VALUES (?, ?)')
        .run(cmdKey(repoId, name), JSON.stringify({ content }));

      return reply.send({ success: true, name });
    },
  );

  // ── POST /api/repos/:repoId/commands ──
  fastify.post<{ Params: RepoParams; Body: CreateCommandBody }>(
    '/api/repos/:repoId/commands',
    async (request, reply) => {
      const { repoId } = request.params;
      const { name, content } = request.body;
      const repo = getRepo(repoId);
      if (!repo) return reply.status(404).send({ error: 'Repo not found' });

      // Check for collision
      const existing = getCustomCommand(repoId, name);
      if (existing !== null || isBuiltInCommand(repo.platform, name)) {
        return reply.status(409).send({ error: `Command already exists: ${name}` });
      }

      fastify.db
        .prepare('INSERT INTO config (key, value) VALUES (?, ?)')
        .run(cmdKey(repoId, name), JSON.stringify({ content }));

      return reply.status(201).send({ success: true, name });
    },
  );

  // ── DELETE /api/repos/:repoId/commands/:name ──
  fastify.delete<{ Params: CommandParams }>(
    '/api/repos/:repoId/commands/:name',
    async (request, reply) => {
      const { repoId, name } = request.params;
      const repo = getRepo(repoId);
      if (!repo) return reply.status(404).send({ error: 'Repo not found' });

      if (isBuiltInCommand(repo.platform, name)) {
        return reply.status(400).send({ error: 'Cannot delete built-in command. Use reset instead.' });
      }

      const result = fastify.db
        .prepare('DELETE FROM config WHERE key = ?')
        .run(cmdKey(repoId, name));

      if (result.changes === 0) {
        return reply.status(404).send({ error: `Custom command not found: ${name}` });
      }

      return reply.send({ success: true, name });
    },
  );

  // ── POST /api/repos/:repoId/commands/:name/reset ──
  fastify.post<{ Params: CommandParams }>(
    '/api/repos/:repoId/commands/:name/reset',
    async (request, reply) => {
      const { repoId, name } = request.params;
      const repo = getRepo(repoId);
      if (!repo) return reply.status(404).send({ error: 'Repo not found' });

      if (!isBuiltInCommand(repo.platform, name)) {
        return reply.status(404).send({ error: `${name} is not a built-in command` });
      }

      fastify.db
        .prepare('DELETE FROM config WHERE key = ?')
        .run(cmdKey(repoId, name));

      const category = getCommandCategory(repo.platform);
      const tpl = loadTemplate(category, name);

      return reply.send({
        name: tpl.name,
        content: tpl.content,
        description: extractDescription(tpl.content, tpl.name),
        isDefault: true,
        isModified: false,
      });
    },
  );
}
```

**Step 4: Register the plugin**

In `src/server/index.ts`:

```typescript
import commandRoutes from './api/commands.js';

// Inside the server setup:
fastify.register(commandRoutes);
```

### 3.3 API Contract

| Method | Path | Request Body | Response | Status Codes |
|--------|------|-------------|----------|--------------|
| `GET` | `/api/repos/:repoId/commands` | — | `CommandResponse[]` | 200, 404 |
| `GET` | `/api/repos/:repoId/commands/:name` | — | `CommandResponse` | 200, 404 |
| `PUT` | `/api/repos/:repoId/commands/:name` | `{ content: string }` | `{ success: true, name }` | 200, 404 |
| `POST` | `/api/repos/:repoId/commands` | `{ name: string, content: string }` | `{ success: true, name }` | 201, 404, 409 |
| `DELETE` | `/api/repos/:repoId/commands/:name` | — | `{ success: true, name }` | 200, 400, 404 |
| `POST` | `/api/repos/:repoId/commands/:name/reset` | — | `CommandResponse` (default) | 200, 404 |

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/api/commands.ts` exists and exports a Fastify plugin with all 6 routes.
- [ ] `GET /api/repos/:repoId/commands` returns defaults + custom commands with correct flags.
- [ ] Default commands are loaded from the correct template category based on the repo's platform.
- [ ] `description` is extracted from the first `# ` heading of each command.
- [ ] `PUT` saves custom content to `config` table with key `commands:{repoId}:{name}`.
- [ ] `POST` creates new custom commands and rejects duplicates (409).
- [ ] `DELETE` removes custom commands and rejects built-in deletions (400).
- [ ] `POST .../reset` removes override and returns default content.
- [ ] All routes return 404 for non-existent repos.
- [ ] Plugin is registered in `src/server/index.ts`.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
