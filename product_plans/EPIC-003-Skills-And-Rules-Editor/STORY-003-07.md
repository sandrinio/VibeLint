---
id: STORY-003-07
parent_epic: EPIC-003
status: Draft
actor: Frontend Developer
complexity: Medium (2-3 files)
---
# STORY-003-07: Markdown Editor Component

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Frontend Developer,
**I want** a reusable MarkdownEditor component (wrapping CodeMirror 6) and a FilePreview component (rendering markdown to HTML),
**So that** the Skills Editor and Rules Editor pages can provide a rich editing experience with syntax highlighting, line numbers, and live preview.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/client/components/MarkdownEditor.tsx` — a CodeMirror 6 wrapper component.
  - Props: `value: string`, `onChange: (value: string) => void`, `readOnly?: boolean`, `language?: string` (default: `"markdown"`).
  - Extensions: markdown syntax highlighting, line numbers, bracket matching, search/replace (`Ctrl+F`/`Cmd+F`), key bindings (default keymap + search keymap).
  - The editor fills its container's height (responsive, no fixed pixel height).
- **Requirement 2**: Create `src/client/components/FilePreview.tsx` — a rendered markdown preview component.
  - Props: `content: string` (raw markdown string).
  - Render markdown to HTML using `marked` (or `markdown-it`).
  - Sanitize rendered HTML with `DOMPurify` to prevent XSS.
  - Apply Tailwind typography styles (`prose` class) for readable rendering.
- **Requirement 3**: Support a side-by-side layout (editor left, preview right) or tabbed layout (edit | preview toggle), controlled by parent component via an optional `layout` prop on a combined `EditorWithPreview` wrapper.
- **Requirement 4**: Install required npm dependencies: `codemirror`, `@codemirror/lang-markdown`, `@codemirror/view`, `@codemirror/state`, `@codemirror/search`, `@codemirror/language`, `marked`, `dompurify`, `@types/dompurify`.
- **Requirement 5**: The editor must update when `value` changes externally (e.g., loading a different skill file) without losing cursor position on internal edits.
- **Requirement 6**: Support a dark/light theme that follows the application's Tailwind theme (or a sensible default theme).

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Markdown Editor Component

  Scenario: Editor renders with initial content
    Given I render MarkdownEditor with value "# Hello World"
    When the component mounts
    Then the CodeMirror editor is visible
    And its content is "# Hello World"
    And line numbers are displayed

  Scenario: Editor calls onChange on user input
    Given I render MarkdownEditor with an onChange handler
    When I type "new text" in the editor
    Then onChange is called with the updated content

  Scenario: Editor respects readOnly prop
    Given I render MarkdownEditor with readOnly true
    When I attempt to type in the editor
    Then the content does not change

  Scenario: Editor updates when value prop changes externally
    Given I render MarkdownEditor with value "original"
    When the parent changes value to "updated content"
    Then the editor content becomes "updated content"

  Scenario: Search and replace works
    Given I render MarkdownEditor with content containing "foo bar foo"
    When I press Cmd+F (or Ctrl+F)
    Then the search panel appears

  Scenario: File preview renders markdown
    Given I render FilePreview with content "# Title\n\nParagraph text"
    When the component mounts
    Then an h1 element with text "Title" is visible
    And a p element with text "Paragraph text" is visible

  Scenario: File preview sanitizes dangerous HTML
    Given I render FilePreview with content "<script>alert('xss')</script>"
    When the component mounts
    Then no script elements exist in the DOM
    And no alert is triggered

  Scenario: Side-by-side layout shows editor and preview together
    Given I render EditorWithPreview with layout "side-by-side"
    When the component mounts
    Then both the editor and preview are visible simultaneously
    And they are arranged horizontally

  Scenario: Tabbed layout toggles between editor and preview
    Given I render EditorWithPreview with layout "tabbed"
    When the component mounts
    Then the editor is visible and preview is hidden
    When I click the "Preview" tab
    Then the preview is visible and the editor is hidden
```

### 2.2 Verification Steps
- [ ] `MarkdownEditor` renders a CodeMirror instance with markdown syntax highlighting.
- [ ] Line numbers, bracket matching, and search/replace are functional.
- [ ] `onChange` fires when content is edited.
- [ ] `readOnly` mode prevents editing.
- [ ] Changing `value` prop externally updates editor content.
- [ ] `FilePreview` renders markdown to styled HTML.
- [ ] `FilePreview` sanitizes XSS vectors (script tags, event handlers).
- [ ] Side-by-side and tabbed layouts both work.
- [ ] Editor fills its container height responsively.
- [ ] All required npm packages are listed in `package.json`.
- [ ] TypeScript compiles with no errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**:
  - `src/client/components/MarkdownEditor.tsx` (create)
  - `src/client/components/FilePreview.tsx` (create)
- **Related Files**:
  - `src/client/components/EditorWithPreview.tsx` (create, optional combined wrapper)
  - `package.json` (modify, add dependencies)
- **New Files Needed**:
  - `src/client/components/MarkdownEditor.tsx`
  - `src/client/components/FilePreview.tsx`
  - `src/client/components/EditorWithPreview.tsx`

### 3.2 Technical Logic

**Step 1: Install dependencies**

Add to `package.json` dependencies:
```json
{
  "codemirror": "^6.0.1",
  "@codemirror/lang-markdown": "^6.3.0",
  "@codemirror/language": "^6.10.0",
  "@codemirror/view": "^6.34.0",
  "@codemirror/state": "^6.4.0",
  "@codemirror/search": "^6.5.0",
  "marked": "^15.0.0",
  "dompurify": "^3.2.0"
}
```

Add to `devDependencies`:
```json
{
  "@types/dompurify": "^3.0.0"
}
```

**Step 2: Implement MarkdownEditor.tsx**

```tsx
// src/client/components/MarkdownEditor.tsx

import React, { useRef, useEffect, useMemo } from 'react';
import { EditorState } from '@codemirror/state';
import { EditorView, keymap, lineNumbers, highlightActiveLine, drawSelection } from '@codemirror/view';
import { defaultKeymap, history, historyKeymap } from '@codemirror/commands';
import { markdown } from '@codemirror/lang-markdown';
import { bracketMatching, syntaxHighlighting, defaultHighlightStyle } from '@codemirror/language';
import { searchKeymap, highlightSelectionMatches } from '@codemirror/search';

export interface MarkdownEditorProps {
  /** Current markdown content */
  value: string;
  /** Callback when content changes */
  onChange: (value: string) => void;
  /** If true, editor is read-only */
  readOnly?: boolean;
  /** Language mode (default: "markdown") — reserved for future extension */
  language?: string;
  /** Optional CSS class for the container */
  className?: string;
}

export const MarkdownEditor: React.FC<MarkdownEditorProps> = ({
  value,
  onChange,
  readOnly = false,
  language = 'markdown',
  className = '',
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const viewRef = useRef<EditorView | null>(null);
  const onChangeRef = useRef(onChange);

  // Keep onChange ref current without recreating the editor
  useEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);

  // Create the editor once on mount
  useEffect(() => {
    if (!containerRef.current) return;

    const updateListener = EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        onChangeRef.current(update.state.doc.toString());
      }
    });

    const extensions = [
      lineNumbers(),
      highlightActiveLine(),
      drawSelection(),
      bracketMatching(),
      history(),
      highlightSelectionMatches(),
      syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
      markdown(),
      keymap.of([...defaultKeymap, ...historyKeymap, ...searchKeymap]),
      updateListener,
      EditorView.lineWrapping,
      // Fill container height
      EditorView.theme({
        '&': { height: '100%' },
        '.cm-scroller': { overflow: 'auto' },
      }),
    ];

    if (readOnly) {
      extensions.push(EditorState.readOnly.of(true));
    }

    const state = EditorState.create({
      doc: value,
      extensions,
    });

    const view = new EditorView({
      state,
      parent: containerRef.current,
    });

    viewRef.current = view;

    return () => {
      view.destroy();
      viewRef.current = null;
    };
  }, [readOnly]); // Recreate only if readOnly changes

  // Sync external value changes into the editor
  useEffect(() => {
    const view = viewRef.current;
    if (!view) return;

    const currentContent = view.state.doc.toString();
    if (currentContent !== value) {
      view.dispatch({
        changes: {
          from: 0,
          to: currentContent.length,
          insert: value,
        },
      });
    }
  }, [value]);

  return (
    <div
      ref={containerRef}
      className={`border border-gray-300 rounded-md overflow-hidden ${className}`}
      style={{ height: '100%', minHeight: '200px' }}
    />
  );
};

export default MarkdownEditor;
```

**Step 3: Implement FilePreview.tsx**

```tsx
// src/client/components/FilePreview.tsx

import React, { useMemo } from 'react';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

export interface FilePreviewProps {
  /** Raw markdown string to render */
  content: string;
  /** Optional CSS class for the container */
  className?: string;
}

export const FilePreview: React.FC<FilePreviewProps> = ({
  content,
  className = '',
}) => {
  const renderedHtml = useMemo(() => {
    // Configure marked for safe rendering
    const rawHtml = marked.parse(content, {
      async: false,
      gfm: true,       // GitHub Flavored Markdown
      breaks: false,    // Don't convert \n to <br>
    }) as string;

    // Sanitize to prevent XSS
    return DOMPurify.sanitize(rawHtml, {
      ALLOWED_TAGS: [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'p', 'br', 'hr',
        'ul', 'ol', 'li',
        'strong', 'em', 'del', 'code', 'pre',
        'blockquote',
        'a', 'img',
        'table', 'thead', 'tbody', 'tr', 'th', 'td',
        'div', 'span',
      ],
      ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'target', 'rel'],
    });
  }, [content]);

  return (
    <div
      className={`prose prose-sm max-w-none overflow-auto p-4 ${className}`}
      dangerouslySetInnerHTML={{ __html: renderedHtml }}
    />
  );
};

export default FilePreview;
```

**Step 4: Implement EditorWithPreview.tsx (combined wrapper)**

```tsx
// src/client/components/EditorWithPreview.tsx

import React, { useState } from 'react';
import { MarkdownEditor, MarkdownEditorProps } from './MarkdownEditor.js';
import { FilePreview } from './FilePreview.js';

export type EditorLayout = 'side-by-side' | 'tabbed';

export interface EditorWithPreviewProps {
  value: string;
  onChange: (value: string) => void;
  readOnly?: boolean;
  /** Layout mode: "side-by-side" or "tabbed" */
  layout?: EditorLayout;
  className?: string;
}

type Tab = 'edit' | 'preview';

export const EditorWithPreview: React.FC<EditorWithPreviewProps> = ({
  value,
  onChange,
  readOnly = false,
  layout = 'side-by-side',
  className = '',
}) => {
  const [activeTab, setActiveTab] = useState<Tab>('edit');

  if (layout === 'side-by-side') {
    return (
      <div className={`flex gap-4 h-full ${className}`}>
        <div className="flex-1 min-w-0">
          <MarkdownEditor value={value} onChange={onChange} readOnly={readOnly} />
        </div>
        <div className="flex-1 min-w-0 border border-gray-300 rounded-md overflow-auto">
          <FilePreview content={value} />
        </div>
      </div>
    );
  }

  // Tabbed layout
  return (
    <div className={`flex flex-col h-full ${className}`}>
      {/* Tab bar */}
      <div className="flex border-b border-gray-300">
        <button
          className={`px-4 py-2 text-sm font-medium ${
            activeTab === 'edit'
              ? 'border-b-2 border-blue-500 text-blue-600'
              : 'text-gray-500 hover:text-gray-700'
          }`}
          onClick={() => setActiveTab('edit')}
        >
          Edit
        </button>
        <button
          className={`px-4 py-2 text-sm font-medium ${
            activeTab === 'preview'
              ? 'border-b-2 border-blue-500 text-blue-600'
              : 'text-gray-500 hover:text-gray-700'
          }`}
          onClick={() => setActiveTab('preview')}
        >
          Preview
        </button>
      </div>

      {/* Content area */}
      <div className="flex-1 min-h-0">
        {activeTab === 'edit' ? (
          <MarkdownEditor value={value} onChange={onChange} readOnly={readOnly} />
        ) : (
          <div className="h-full border border-gray-300 rounded-b-md overflow-auto">
            <FilePreview content={value} />
          </div>
        )}
      </div>
    </div>
  );
};

export default EditorWithPreview;
```

**Step 5: Tailwind Typography Plugin**

Ensure the Tailwind CSS config includes the `@tailwindcss/typography` plugin for the `prose` class used by `FilePreview`:

```bash
npm install -D @tailwindcss/typography
```

In `tailwind.config.js` (or `.ts`):
```javascript
export default {
  // ...
  plugins: [
    require('@tailwindcss/typography'),
  ],
};
```

### 3.3 API Contract
N/A — these are frontend components with no backend API. They consume data passed via props from parent pages.

**Component Interface Summary:**

| Component | Props | Description |
|-----------|-------|-------------|
| `MarkdownEditor` | `value, onChange, readOnly?, language?, className?` | CodeMirror 6 markdown editor |
| `FilePreview` | `content, className?` | Rendered markdown preview with XSS sanitization |
| `EditorWithPreview` | `value, onChange, readOnly?, layout?, className?` | Combined editor + preview with layout options |

---

## 4. Definition of Done (The Gate)
- [ ] `src/client/components/MarkdownEditor.tsx` exists and renders a CodeMirror 6 editor.
- [ ] Editor has markdown syntax highlighting, line numbers, bracket matching, and search/replace.
- [ ] `onChange` fires on content changes; `readOnly` prevents editing.
- [ ] External `value` changes update the editor content.
- [ ] Editor fills its container height responsively.
- [ ] `src/client/components/FilePreview.tsx` exists and renders markdown to styled HTML.
- [ ] HTML output is sanitized with DOMPurify (no XSS).
- [ ] `src/client/components/EditorWithPreview.tsx` exists with side-by-side and tabbed layouts.
- [ ] Required npm dependencies are installed: `codemirror`, `@codemirror/lang-markdown`, `@codemirror/view`, `@codemirror/state`, `@codemirror/search`, `@codemirror/language`, `marked`, `dompurify`, `@types/dompurify`, `@tailwindcss/typography`.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
