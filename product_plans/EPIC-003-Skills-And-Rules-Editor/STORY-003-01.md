---
id: STORY-003-01
parent_epic: EPIC-003
status: Draft
actor: Backend Developer
complexity: Low (1 file)
---
# STORY-003-01: Template System

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a template loader module that reads default templates from the bundled `templates/` directory,
**So that** the skills, rules, and commands APIs can serve default content for any category without duplicating file-reading logic.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/server/templates/loader.ts` exporting `loadTemplate(category, name)` and `listTemplates(category)`.
- **Requirement 2**: `loadTemplate(category, name)` reads a file from `templates/{category}/{name}` relative to the project root and returns a `TemplateResult` object containing `{ name, category, content, isDefault: true }`.
- **Requirement 3**: `listTemplates(category)` returns an array of `TemplateResult` objects for every file in `templates/{category}/`, recursing one level into subdirectories (e.g., `rules/claude-code/CLAUDE.md.template`).
- **Requirement 4**: Supported categories: `skills`, `rules/claude-code`, `rules/cursor`, `rules/windsurf`, `rules/generic`, `commands/claude-code`, `commands/generic`, `config`.
- **Requirement 5**: Templates are read-only defaults bundled with the npm package. The loader never writes to the templates directory.
- **Requirement 6**: If a requested template does not exist, `loadTemplate` throws a typed `TemplateNotFoundError` with the category and name in the message.
- **Requirement 7**: The module must resolve the `templates/` directory relative to the package root (using `import.meta.url` or `__dirname` equivalent for ESM), so it works regardless of the working directory.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Template Loader

  Scenario: Load a specific template by category and name
    Given the templates directory contains "skills/general.md"
    When I call loadTemplate("skills", "general.md")
    Then it returns an object with name "general.md"
    And category "skills"
    And content matching the file contents
    And isDefault is true

  Scenario: List all templates in a category
    Given the templates directory contains files in "skills/"
    When I call listTemplates("skills")
    Then it returns an array of TemplateResult objects
    And each object has isDefault true
    And the array length matches the number of files in templates/skills/

  Scenario: List templates in a nested category
    Given the templates directory contains "rules/claude-code/CLAUDE.md.template"
    When I call listTemplates("rules/claude-code")
    Then it returns an array containing an entry with name "CLAUDE.md.template"

  Scenario: Template not found
    Given no file exists at "skills/nonexistent.md"
    When I call loadTemplate("skills", "nonexistent.md")
    Then it throws a TemplateNotFoundError
    And the error message contains "skills" and "nonexistent.md"

  Scenario: Templates directory resolves from package root
    Given the process working directory is "/tmp"
    When I call loadTemplate("skills", "general.md")
    Then it still resolves the file correctly from the package root
```

### 2.2 Verification Steps
- [ ] `loadTemplate("skills", "general.md")` returns valid content with `isDefault: true`.
- [ ] `listTemplates("skills")` returns 10 entries after STORY-003-02 is complete.
- [ ] `listTemplates("rules/claude-code")` returns entries from the nested subdirectory.
- [ ] `loadTemplate("skills", "nonexistent.md")` throws `TemplateNotFoundError`.
- [ ] Module works when invoked from any working directory.
- [ ] TypeScript compiles with `npx tsc --noEmit` — no type errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/templates/loader.ts` (create)
- **Related Files**: `templates/` directory (read-only, populated by STORY-003-02 and STORY-003-03)
- **New Files Needed**:
  - `src/server/templates/loader.ts`

### 3.2 Technical Logic

**Step 1: Define types**

```typescript
// src/server/templates/loader.ts

export interface TemplateResult {
  /** Filename, e.g. "general.md" */
  name: string;
  /** Category path, e.g. "skills" or "rules/claude-code" */
  category: string;
  /** Raw file content (UTF-8) */
  content: string;
  /** Always true for templates loaded from the bundled templates/ directory */
  isDefault: true;
}

export class TemplateNotFoundError extends Error {
  constructor(category: string, name: string) {
    super(`Template not found: ${category}/${name}`);
    this.name = 'TemplateNotFoundError';
  }
}
```

**Step 2: Resolve the templates root directory**

```typescript
import { fileURLToPath } from 'node:url';
import path from 'node:path';
import fs from 'node:fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Navigate from src/server/templates/ up to project root, then into templates/
const TEMPLATES_ROOT = path.resolve(__dirname, '..', '..', '..', 'templates');
```

**Step 3: Implement `loadTemplate`**

```typescript
export function loadTemplate(category: string, name: string): TemplateResult {
  const filePath = path.join(TEMPLATES_ROOT, category, name);

  if (!fs.existsSync(filePath) || !fs.statSync(filePath).isFile()) {
    throw new TemplateNotFoundError(category, name);
  }

  const content = fs.readFileSync(filePath, 'utf-8');

  return {
    name,
    category,
    content,
    isDefault: true,
  };
}
```

**Step 4: Implement `listTemplates`**

```typescript
export function listTemplates(category: string): TemplateResult[] {
  const dirPath = path.join(TEMPLATES_ROOT, category);

  if (!fs.existsSync(dirPath) || !fs.statSync(dirPath).isDirectory()) {
    return [];
  }

  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  const results: TemplateResult[] = [];

  for (const entry of entries) {
    if (entry.isFile() && !entry.name.startsWith('.')) {
      const content = fs.readFileSync(path.join(dirPath, entry.name), 'utf-8');
      results.push({
        name: entry.name,
        category,
        content,
        isDefault: true,
      });
    }
    // Do NOT recurse into subdirectories here — subdirectories are separate categories
    // e.g., "rules/claude-code" is its own category, not a child of "rules"
  }

  return results.sort((a, b) => a.name.localeCompare(b.name));
}
```

**Step 5: Export a helper to get all categories**

```typescript
export const TEMPLATE_CATEGORIES = [
  'skills',
  'rules/claude-code',
  'rules/cursor',
  'rules/windsurf',
  'rules/generic',
  'commands/claude-code',
  'commands/generic',
  'config',
] as const;

export type TemplateCategory = (typeof TEMPLATE_CATEGORIES)[number];

/**
 * List all templates across all categories.
 * Returns a flat array of TemplateResult grouped by category.
 */
export function listAllTemplates(): TemplateResult[] {
  return TEMPLATE_CATEGORIES.flatMap((cat) => listTemplates(cat));
}
```

### 3.3 API Contract
N/A — this story is a server-side module only. It is consumed by the API routes in STORY-003-04, STORY-003-05, and STORY-003-06.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/templates/loader.ts` exists and exports `loadTemplate`, `listTemplates`, `listAllTemplates`, `TemplateResult`, `TemplateNotFoundError`, `TEMPLATE_CATEGORIES`.
- [ ] `loadTemplate` reads a template file and returns `{ name, category, content, isDefault: true }`.
- [ ] `listTemplates` lists all files in a given category directory.
- [ ] `loadTemplate` throws `TemplateNotFoundError` for missing templates.
- [ ] Template path resolution uses `import.meta.url` so it works from any cwd.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
- [ ] No writes to the `templates/` directory occur anywhere in the module.
