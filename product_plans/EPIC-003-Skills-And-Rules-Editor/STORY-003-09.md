---
id: STORY-003-09
parent_epic: EPIC-003
status: Done
actor: Frontend Developer
complexity: High (4+ files)
---
# STORY-003-09: Rules Editor Page

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Frontend Developer,
**I want** a Rules Editor page where users can edit their platform-specific rules file (CLAUDE.md, .cursorrules, etc.), manage slash commands, and edit LESSONS.md for a selected repository,
**So that** users can customize all the platform-specific context files from a single page before injecting them into their repos.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/client/pages/RulesEditor.tsx` as a routable page component.
- **Requirement 2**: Include a repo selector dropdown at the top (same pattern as Skills Editor), populated from connected repos.
- **Requirement 3**: The page is organized into three collapsible sections:
  - **Section 1: Platform Rules** — MarkdownEditor for the main rules file (CLAUDE.md for Claude Code, .cursorrules for Cursor, etc.). The section heading dynamically shows the correct file name based on the repo's platform setting.
  - **Section 2: Slash Commands** — List of commands with click-to-edit behavior. Each command opens in a MarkdownEditor. Includes a "+ Add Custom Command" button.
  - **Section 3: LESSONS.md** — MarkdownEditor for the LESSONS.md file.
- **Requirement 4**: Each section has its own Save and Reset to Default buttons. Save/Reset operate independently per section.
- **Requirement 5**: Platform Rules section loads from `GET /api/repos/:repoId/rules/:type` and saves via `PUT /api/repos/:repoId/rules/:type`.
- **Requirement 6**: Slash Commands section loads from `GET /api/repos/:repoId/commands` and supports:
  - Viewing the list of commands with descriptions
  - Clicking a command to edit its content in a MarkdownEditor
  - Saving edits via `PUT /api/repos/:repoId/commands/:name`
  - Creating new commands via `POST /api/repos/:repoId/commands`
  - Deleting custom commands via `DELETE /api/repos/:repoId/commands/:name`
  - Resetting commands via `POST /api/repos/:repoId/commands/:name/reset`
- **Requirement 7**: LESSONS.md section loads from `GET /api/repos/:repoId/rules/lessons-md` and saves via `PUT /api/repos/:repoId/rules/lessons-md`.
- **Requirement 8**: The platform label is derived from the repo's settings. Display names: "CLAUDE.md" for Claude Code, ".cursorrules" for Cursor, ".windsurfrules" for Windsurf, "AGENTS.md" for generic.
- **Requirement 9**: Show success/error notifications on save operations (toast or inline).

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Rules Editor Page

  Background:
    Given a repo "my-app" exists with platform "claude-code"
    And the Rules Editor page is loaded with "my-app" selected

  Scenario: Platform Rules section shows correct file name
    When the page loads
    Then the Platform Rules section heading shows "CLAUDE.md"
    And the editor loads the CLAUDE.md template content

  Scenario: Platform Rules section for Cursor shows .cursorrules
    Given a repo "cursor-app" exists with platform "cursor"
    When I select "cursor-app" in the repo selector
    Then the Platform Rules section heading shows ".cursorrules"

  Scenario: Edit and save platform rules
    Given the CLAUDE.md content is loaded in the editor
    When I modify the content
    And I click "Save" in the Platform Rules section
    Then a PUT request is sent to /api/repos/:repoId/rules/claude-md
    And a success notification is shown

  Scenario: Reset platform rules to default
    Given CLAUDE.md has been modified
    When I click "Reset to Default" in the Platform Rules section
    Then the content reverts to the default CLAUDE.md template
    And a POST request is sent to /api/repos/:repoId/rules/claude-md/reset

  Scenario: Slash Commands section lists all commands
    When the page loads
    Then the Slash Commands section lists: review, check, health, vdoc-init, vdoc-update
    And each shows a description (e.g., "Code Review", "Pre-Commit Quality Check")

  Scenario: Edit a slash command
    Given the commands list is visible
    When I click on "review.md"
    Then a MarkdownEditor opens with the review command content
    And Save and Reset buttons are available

  Scenario: Save a slash command
    Given "review.md" is open in the editor
    When I modify the content and click "Save"
    Then a PUT request saves the content
    And a success notification is shown

  Scenario: Create a new custom command
    When I click "+ Add Custom Command"
    Then a dialog appears with a name input
    When I enter "deploy.md" and confirm
    Then the command is created via POST
    And it appears in the commands list

  Scenario: Delete a custom command
    Given a custom command "deploy.md" exists
    When I click the delete button on "deploy.md"
    Then a confirmation dialog appears
    When I confirm
    Then the command is deleted via DELETE

  Scenario: LESSONS.md section loads and saves
    When the page loads
    Then the LESSONS.md section shows the LESSONS.md content in an editor
    When I modify the content and click "Save" in the LESSONS.md section
    Then a PUT request saves the LESSONS.md content

  Scenario: Collapsible sections
    Given all three sections are visible
    When I click the Platform Rules section header
    Then the Platform Rules editor collapses
    When I click it again
    Then it expands

  Scenario: No repos connected shows empty state
    Given no repos are connected
    When I navigate to the Rules Editor
    Then an empty state message is shown
```

### 2.2 Verification Steps
- [ ] Repo selector populates from `GET /api/repos`.
- [ ] Platform Rules section heading shows the correct file name based on platform.
- [ ] Platform rules load from `GET /api/repos/:repoId/rules/:type`.
- [ ] Save on platform rules calls `PUT /api/repos/:repoId/rules/:type`.
- [ ] Reset on platform rules calls `POST .../reset`.
- [ ] Slash Commands section lists commands from `GET /api/repos/:repoId/commands`.
- [ ] Clicking a command opens it in a MarkdownEditor.
- [ ] Command save, create, delete, and reset all work.
- [ ] LESSONS.md loads from `GET /api/repos/:repoId/rules/lessons-md`.
- [ ] LESSONS.md save calls `PUT /api/repos/:repoId/rules/lessons-md`.
- [ ] Sections are collapsible.
- [ ] Notifications display on save success/failure.
- [ ] Empty state shows when no repos exist.
- [ ] TypeScript compiles with no errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/client/pages/RulesEditor.tsx` (create)
- **Related Files**:
  - `src/client/components/MarkdownEditor.tsx` (STORY-003-07)
  - `src/client/components/EditorWithPreview.tsx` (STORY-003-07)
  - `src/client/lib/api.ts` (modify, add rules and commands API functions)
  - `src/client/App.tsx` (modify, add route)
- **New Files Needed**:
  - `src/client/pages/RulesEditor.tsx`

### 3.2 Technical Logic

**Step 1: Add API client functions for rules and commands**

Add to `src/client/lib/api.ts`:

```typescript
// ── Rules API types ──

export interface RuleResponse {
  type: string;
  displayName: string;
  content: string;
  isDefault: boolean;
  isModified: boolean;
}

export interface RulesListResponse {
  platform: string;
  platformRule: RuleResponse;
  lessonsRule: RuleResponse;
}

export interface CommandResponse {
  name: string;
  content: string;
  description: string;
  isDefault: boolean;
  isModified: boolean;
}

// ── Rules API functions ──

export async function fetchRules(repoId: string): Promise<RulesListResponse> {
  const res = await fetch(`/api/repos/${repoId}/rules`);
  if (!res.ok) throw new Error(`Failed to fetch rules: ${res.statusText}`);
  return res.json();
}

export async function fetchRule(repoId: string, type: string): Promise<RuleResponse> {
  const res = await fetch(`/api/repos/${repoId}/rules/${type}`);
  if (!res.ok) throw new Error(`Failed to fetch rule: ${res.statusText}`);
  return res.json();
}

export async function saveRule(repoId: string, type: string, content: string): Promise<void> {
  const res = await fetch(`/api/repos/${repoId}/rules/${type}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content }),
  });
  if (!res.ok) throw new Error(`Failed to save rule: ${res.statusText}`);
}

export async function resetRule(repoId: string, type: string): Promise<RuleResponse> {
  const res = await fetch(`/api/repos/${repoId}/rules/${type}/reset`, { method: 'POST' });
  if (!res.ok) throw new Error(`Failed to reset rule: ${res.statusText}`);
  return res.json();
}

// ── Commands API functions ──

export async function fetchCommands(repoId: string): Promise<CommandResponse[]> {
  const res = await fetch(`/api/repos/${repoId}/commands`);
  if (!res.ok) throw new Error(`Failed to fetch commands: ${res.statusText}`);
  return res.json();
}

export async function fetchCommand(repoId: string, name: string): Promise<CommandResponse> {
  const res = await fetch(`/api/repos/${repoId}/commands/${encodeURIComponent(name)}`);
  if (!res.ok) throw new Error(`Failed to fetch command: ${res.statusText}`);
  return res.json();
}

export async function saveCommand(repoId: string, name: string, content: string): Promise<void> {
  const res = await fetch(`/api/repos/${repoId}/commands/${encodeURIComponent(name)}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content }),
  });
  if (!res.ok) throw new Error(`Failed to save command: ${res.statusText}`);
}

export async function createCommand(repoId: string, name: string, content: string): Promise<void> {
  const res = await fetch(`/api/repos/${repoId}/commands`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, content }),
  });
  if (!res.ok) {
    if (res.status === 409) throw new Error('A command with that name already exists');
    throw new Error(`Failed to create command: ${res.statusText}`);
  }
}

export async function deleteCommand(repoId: string, name: string): Promise<void> {
  const res = await fetch(`/api/repos/${repoId}/commands/${encodeURIComponent(name)}`, {
    method: 'DELETE',
  });
  if (!res.ok) throw new Error(`Failed to delete command: ${res.statusText}`);
}

export async function resetCommand(repoId: string, name: string): Promise<CommandResponse> {
  const res = await fetch(`/api/repos/${repoId}/commands/${encodeURIComponent(name)}/reset`, {
    method: 'POST',
  });
  if (!res.ok) throw new Error(`Failed to reset command: ${res.statusText}`);
  return res.json();
}
```

**Step 2: Implement the CollapsibleSection sub-component**

```tsx
// Inside src/client/pages/RulesEditor.tsx or as a shared component

interface CollapsibleSectionProps {
  title: string;
  defaultOpen?: boolean;
  children: React.ReactNode;
}

const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  defaultOpen = true,
  children,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="border border-gray-200 rounded-lg mb-4">
      <button
        className="w-full flex items-center justify-between px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-t-lg text-left"
        onClick={() => setIsOpen(!isOpen)}
      >
        <h2 className="text-base font-semibold">{title}</h2>
        <span className="text-gray-400">{isOpen ? '\u25B2' : '\u25BC'}</span>
      </button>
      {isOpen && <div className="p-4">{children}</div>}
    </div>
  );
};
```

**Step 3: Implement the RulesEditor page**

```tsx
// src/client/pages/RulesEditor.tsx

import React, { useState, useEffect, useCallback } from 'react';
import { EditorWithPreview } from '../components/EditorWithPreview.js';
import {
  fetchRules,
  saveRule,
  resetRule,
  fetchCommands,
  saveCommand,
  createCommand,
  deleteCommand,
  resetCommand,
  RulesListResponse,
  RuleResponse,
  CommandResponse,
} from '../lib/api.js';

interface Repo {
  id: string;
  name: string;
  platform: string;
}

export const RulesEditor: React.FC = () => {
  // ── Shared state ──
  const [repos, setRepos] = useState<Repo[]>([]);
  const [selectedRepoId, setSelectedRepoId] = useState<string>('');
  const [notification, setNotification] = useState<{
    type: 'success' | 'error';
    message: string;
  } | null>(null);

  // ── Platform Rules state ──
  const [rulesData, setRulesData] = useState<RulesListResponse | null>(null);
  const [platformContent, setPlatformContent] = useState('');
  const [platformDirty, setPlatformDirty] = useState(false);

  // ── Commands state ──
  const [commands, setCommands] = useState<CommandResponse[]>([]);
  const [selectedCommand, setSelectedCommand] = useState<CommandResponse | null>(null);
  const [commandContent, setCommandContent] = useState('');
  const [commandDirty, setCommandDirty] = useState(false);
  const [showCreateCommandDialog, setShowCreateCommandDialog] = useState(false);
  const [newCommandName, setNewCommandName] = useState('');

  // ── LESSONS.md state ──
  const [lessonsContent, setLessonsContent] = useState('');
  const [lessonsDirty, setLessonsDirty] = useState(false);

  // ── Load repos ──
  useEffect(() => {
    fetch('/api/repos')
      .then((res) => res.json())
      .then((data: Repo[]) => {
        setRepos(data);
        if (data.length > 0) setSelectedRepoId(data[0].id);
      });
  }, []);

  // ── Load data when repo changes ──
  useEffect(() => {
    if (!selectedRepoId) return;

    // Load rules (platform + LESSONS.md)
    fetchRules(selectedRepoId).then((data) => {
      setRulesData(data);
      setPlatformContent(data.platformRule.content);
      setPlatformDirty(false);
      setLessonsContent(data.lessonsRule.content);
      setLessonsDirty(false);
    });

    // Load commands
    fetchCommands(selectedRepoId).then((data) => {
      setCommands(data);
      setSelectedCommand(null);
      setCommandContent('');
      setCommandDirty(false);
    });
  }, [selectedRepoId]);

  // ── Notification helper ──
  const notify = useCallback((type: 'success' | 'error', message: string) => {
    setNotification({ type, message });
    if (type === 'success') {
      setTimeout(() => setNotification(null), 3000);
    }
  }, []);

  // ── Platform Rules handlers ──
  const handleSavePlatformRule = useCallback(async () => {
    if (!selectedRepoId || !rulesData) return;
    try {
      await saveRule(selectedRepoId, rulesData.platformRule.type, platformContent);
      setPlatformDirty(false);
      notify('success', `${rulesData.platformRule.displayName} saved`);
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, rulesData, platformContent, notify]);

  const handleResetPlatformRule = useCallback(async () => {
    if (!selectedRepoId || !rulesData) return;
    try {
      const result = await resetRule(selectedRepoId, rulesData.platformRule.type);
      setPlatformContent(result.content);
      setPlatformDirty(false);
      notify('success', `${rulesData.platformRule.displayName} reset to default`);
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, rulesData, notify]);

  // ── Command handlers ──
  const handleSelectCommand = useCallback((cmd: CommandResponse) => {
    setSelectedCommand(cmd);
    setCommandContent(cmd.content);
    setCommandDirty(false);
  }, []);

  const handleSaveCommand = useCallback(async () => {
    if (!selectedRepoId || !selectedCommand) return;
    try {
      await saveCommand(selectedRepoId, selectedCommand.name, commandContent);
      setCommandDirty(false);
      notify('success', `Command "${selectedCommand.name}" saved`);
      // Refresh commands list
      const updated = await fetchCommands(selectedRepoId);
      setCommands(updated);
      const refreshed = updated.find((c) => c.name === selectedCommand.name);
      if (refreshed) setSelectedCommand(refreshed);
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, selectedCommand, commandContent, notify]);

  const handleResetCommand = useCallback(async () => {
    if (!selectedRepoId || !selectedCommand) return;
    try {
      const result = await resetCommand(selectedRepoId, selectedCommand.name);
      setCommandContent(result.content);
      setSelectedCommand(result);
      setCommandDirty(false);
      notify('success', `Command "${selectedCommand.name}" reset to default`);
      const updated = await fetchCommands(selectedRepoId);
      setCommands(updated);
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, selectedCommand, notify]);

  const handleCreateCommand = useCallback(async () => {
    if (!selectedRepoId || !newCommandName.trim()) return;
    const name = newCommandName.trim().endsWith('.md')
      ? newCommandName.trim()
      : `${newCommandName.trim()}.md`;
    try {
      const defaultContent = `# ${name.replace('.md', '').replace(/-/g, ' ')}\n\nDescribe this command's purpose and steps.\n\n## Steps\n\n1. Step one\n2. Step two\n\n## Output Format\n\nDescribe expected output.\n`;
      await createCommand(selectedRepoId, name, defaultContent);
      setShowCreateCommandDialog(false);
      setNewCommandName('');
      const updated = await fetchCommands(selectedRepoId);
      setCommands(updated);
      const newCmd = updated.find((c) => c.name === name);
      if (newCmd) handleSelectCommand(newCmd);
      notify('success', `Command "${name}" created`);
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, newCommandName, handleSelectCommand, notify]);

  const handleDeleteCommand = useCallback(async (name: string) => {
    if (!selectedRepoId) return;
    if (!confirm(`Delete command "${name}"?`)) return;
    try {
      await deleteCommand(selectedRepoId, name);
      const updated = await fetchCommands(selectedRepoId);
      setCommands(updated);
      if (selectedCommand?.name === name) {
        setSelectedCommand(null);
        setCommandContent('');
      }
      notify('success', `Command "${name}" deleted`);
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, selectedCommand, notify]);

  // ── LESSONS.md handlers ──
  const handleSaveLessons = useCallback(async () => {
    if (!selectedRepoId) return;
    try {
      await saveRule(selectedRepoId, 'lessons-md', lessonsContent);
      setLessonsDirty(false);
      notify('success', 'LESSONS.md saved');
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, lessonsContent, notify]);

  const handleResetLessons = useCallback(async () => {
    if (!selectedRepoId) return;
    try {
      const result = await resetRule(selectedRepoId, 'lessons-md');
      setLessonsContent(result.content);
      setLessonsDirty(false);
      notify('success', 'LESSONS.md reset to default');
    } catch (err) {
      notify('error', (err as Error).message);
    }
  }, [selectedRepoId, notify]);

  // ── Empty state ──
  if (repos.length === 0) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center text-gray-500">
          <h2 className="text-xl font-semibold mb-2">No Repositories Connected</h2>
          <p>Connect a repository in Settings to start editing rules.</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full overflow-y-auto">
      {/* Header */}
      <div className="flex items-center gap-4 p-4 border-b border-gray-200 sticky top-0 bg-white z-10">
        <h1 className="text-lg font-semibold">Rules Editor</h1>
        <select
          value={selectedRepoId}
          onChange={(e) => setSelectedRepoId(e.target.value)}
          className="border border-gray-300 rounded px-3 py-1.5 text-sm"
        >
          {repos.map((repo) => (
            <option key={repo.id} value={repo.id}>{repo.name}</option>
          ))}
        </select>
      </div>

      {/* Notification */}
      {notification && (
        <div className={`mx-4 mt-2 px-4 py-2 rounded text-sm ${
          notification.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
        }`}>
          {notification.message}
          <button onClick={() => setNotification(null)} className="ml-2 font-bold">x</button>
        </div>
      )}

      {/* Content */}
      <div className="p-4 space-y-4">

        {/* ── Section 1: Platform Rules ── */}
        {rulesData && (
          <CollapsibleSection title={`Platform Rules \u2014 ${rulesData.platformRule.displayName}`}>
            <div className="flex justify-end gap-2 mb-2">
              <button
                onClick={handleResetPlatformRule}
                className="px-3 py-1 text-sm border border-gray-300 rounded hover:bg-gray-50"
              >
                Reset to Default
              </button>
              <button
                onClick={handleSavePlatformRule}
                disabled={!platformDirty}
                className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
              >
                Save
              </button>
            </div>
            <div style={{ height: '400px' }}>
              <EditorWithPreview
                value={platformContent}
                onChange={(v) => { setPlatformContent(v); setPlatformDirty(true); }}
                layout="tabbed"
              />
            </div>
          </CollapsibleSection>
        )}

        {/* ── Section 2: Slash Commands ── */}
        <CollapsibleSection title="Slash Commands">
          <div className="flex gap-4" style={{ minHeight: '350px' }}>
            {/* Commands list */}
            <div className="w-56 border-r border-gray-200 pr-3">
              <ul className="space-y-1 mb-3">
                {commands.map((cmd) => (
                  <li
                    key={cmd.name}
                    className={`flex items-center justify-between px-2 py-1.5 rounded cursor-pointer text-sm ${
                      selectedCommand?.name === cmd.name
                        ? 'bg-blue-100 text-blue-800'
                        : 'hover:bg-gray-100'
                    }`}
                    onClick={() => handleSelectCommand(cmd)}
                  >
                    <div className="truncate">
                      <span className="font-mono text-xs">/{cmd.name.replace('.md', '')}</span>
                      {cmd.isModified && (
                        <span className="ml-1 w-2 h-2 bg-yellow-500 rounded-full inline-block" />
                      )}
                      <div className="text-xs text-gray-500 truncate">{cmd.description}</div>
                    </div>
                    {!cmd.isDefault && !cmd.isModified && (
                      <button
                        onClick={(e) => { e.stopPropagation(); handleDeleteCommand(cmd.name); }}
                        className="text-red-400 hover:text-red-600 text-xs ml-1 flex-shrink-0"
                        title="Delete"
                      >
                        x
                      </button>
                    )}
                  </li>
                ))}
              </ul>
              <button
                onClick={() => setShowCreateCommandDialog(true)}
                className="w-full px-2 py-1.5 text-sm text-blue-600 border border-blue-300 rounded hover:bg-blue-50"
              >
                + Add Custom Command
              </button>
            </div>

            {/* Command editor */}
            <div className="flex-1 flex flex-col min-w-0">
              {selectedCommand ? (
                <>
                  <div className="flex items-center justify-between mb-2">
                    <span className="font-medium text-sm font-mono">
                      /{selectedCommand.name.replace('.md', '')}
                      {commandDirty && <span className="ml-2 text-xs text-yellow-600">(unsaved)</span>}
                    </span>
                    <div className="flex gap-2">
                      {(selectedCommand.isDefault || selectedCommand.isModified) && (
                        <button
                          onClick={handleResetCommand}
                          className="px-3 py-1 text-sm border border-gray-300 rounded hover:bg-gray-50"
                        >
                          Reset
                        </button>
                      )}
                      <button
                        onClick={handleSaveCommand}
                        disabled={!commandDirty}
                        className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
                      >
                        Save
                      </button>
                    </div>
                  </div>
                  <div className="flex-1" style={{ minHeight: '250px' }}>
                    <EditorWithPreview
                      value={commandContent}
                      onChange={(v) => { setCommandContent(v); setCommandDirty(true); }}
                      layout="tabbed"
                    />
                  </div>
                </>
              ) : (
                <div className="flex items-center justify-center h-full text-gray-400 text-sm">
                  Select a command from the list to edit
                </div>
              )}
            </div>
          </div>
        </CollapsibleSection>

        {/* ── Section 3: LESSONS.md ── */}
        <CollapsibleSection title="LESSONS.md">
          <div className="flex justify-end gap-2 mb-2">
            <button
              onClick={handleResetLessons}
              className="px-3 py-1 text-sm border border-gray-300 rounded hover:bg-gray-50"
            >
              Reset to Default
            </button>
            <button
              onClick={handleSaveLessons}
              disabled={!lessonsDirty}
              className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              Save
            </button>
          </div>
          <div style={{ height: '350px' }}>
            <EditorWithPreview
              value={lessonsContent}
              onChange={(v) => { setLessonsContent(v); setLessonsDirty(true); }}
              layout="tabbed"
            />
          </div>
        </CollapsibleSection>
      </div>

      {/* Create Command Dialog */}
      {showCreateCommandDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl p-6 w-96">
            <h3 className="text-lg font-semibold mb-4">Add Custom Command</h3>
            <input
              type="text"
              placeholder="command-name.md"
              value={newCommandName}
              onChange={(e) => setNewCommandName(e.target.value)}
              onKeyDown={(e) => { if (e.key === 'Enter') handleCreateCommand(); }}
              className="w-full border border-gray-300 rounded px-3 py-2 mb-4 text-sm"
              autoFocus
            />
            <p className="text-xs text-gray-500 mb-4">
              The command will be available as /{newCommandName.replace('.md', '') || 'command-name'}
            </p>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => { setShowCreateCommandDialog(false); setNewCommandName(''); }}
                className="px-4 py-2 text-sm border border-gray-300 rounded hover:bg-gray-50"
              >
                Cancel
              </button>
              <button
                onClick={handleCreateCommand}
                disabled={!newCommandName.trim()}
                className="px-4 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default RulesEditor;
```

**Step 4: Add the route in App.tsx**

In `src/client/App.tsx`:

```tsx
import { RulesEditor } from './pages/RulesEditor.js';

// Inside the router:
<Route path="/rules" element={<RulesEditor />} />
```

Ensure the navigation bar includes a "Rules" link pointing to `/rules`.

### 3.3 API Contract

This page consumes the following APIs:

| Action | Method | Endpoint | Purpose |
|--------|--------|----------|---------|
| Load repos | `GET` | `/api/repos` | Populate repo selector |
| Load rules | `GET` | `/api/repos/:repoId/rules` | Get platform rule + LESSONS.md |
| Get rule | `GET` | `/api/repos/:repoId/rules/:type` | Get specific rule content |
| Save rule | `PUT` | `/api/repos/:repoId/rules/:type` | Save platform rules or LESSONS.md |
| Reset rule | `POST` | `/api/repos/:repoId/rules/:type/reset` | Revert to default template |
| List commands | `GET` | `/api/repos/:repoId/commands` | Populate commands list |
| Save command | `PUT` | `/api/repos/:repoId/commands/:name` | Save command edits |
| Create command | `POST` | `/api/repos/:repoId/commands` | Create custom command |
| Delete command | `DELETE` | `/api/repos/:repoId/commands/:name` | Remove custom command |
| Reset command | `POST` | `/api/repos/:repoId/commands/:name/reset` | Revert command to default |

---

## 4. Definition of Done (The Gate)
- [ ] `src/client/pages/RulesEditor.tsx` exists and renders a full Rules Editor page.
- [ ] Repo selector dropdown populates from connected repos.
- [ ] Platform Rules section dynamically shows the correct file name (CLAUDE.md, .cursorrules, etc.) based on the repo's platform.
- [ ] Platform rules load, save, and reset correctly.
- [ ] Slash Commands section lists commands with descriptions.
- [ ] Clicking a command opens it in a MarkdownEditor.
- [ ] Command save, create, delete, and reset all function correctly.
- [ ] LESSONS.md section loads, saves, and resets correctly.
- [ ] All three sections are independently collapsible.
- [ ] Success/error notifications display on save operations.
- [ ] Empty state shows when no repos are connected.
- [ ] "+ Add Custom Command" dialog creates new commands.
- [ ] Route is registered in `App.tsx` at `/rules`.
- [ ] API client functions for rules and commands added to `src/client/lib/api.ts`.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
