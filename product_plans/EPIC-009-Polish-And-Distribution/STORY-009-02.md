---
id: STORY-009-02
parent_epic: EPIC-009
status: Draft
actor: Full-Stack Developer
complexity: High (4+ files)
---
# STORY-009-02: Performance Optimization

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Full-Stack Developer,
**I want** configurable limits on file scanning, timeouts on analyzer checks and git operations, lazy-loaded frontend pages and heavy components, and loading indicators for all async data,
**So that** VibeLint handles repos with 50,000+ files without freezing, long-running operations can be cancelled, and the UI feels responsive even before data arrives.

### 1.2 Detailed Requirements
- **Requirement 1**: File scanning — add a configurable `maxFileLimit` (default 5000) to the file scanner. Skip binary files by extension (`.png`, `.jpg`, `.gif`, `.ico`, `.woff`, `.woff2`, `.ttf`, `.eot`, `.mp3`, `.mp4`, `.zip`, `.tar`, `.gz`, `.exe`, `.dll`, `.so`, `.dylib`, `.pdf`, `.lock`). Store the limit in `config` table.
- **Requirement 2**: Analyzer — add a per-check timeout (default 30 seconds). If a check exceeds the timeout, cancel it and mark that check as `"TIMEOUT"` in the results instead of failing the entire analysis.
- **Requirement 3**: Git operations — add timeouts: 10 seconds for branch listing / file listing, 30 seconds for diffs. Use `AbortController` or `setTimeout` + `kill` on child processes.
- **Requirement 4**: Frontend — lazy load all page components with `React.lazy()` + `Suspense`. Pages to lazy load: `Dashboard`, `SkillsEditor`, `RulesEditor`, `AnalysisView`, `PRNavigator`, `Trends`, `DocsStatus`, `Settings`.
- **Requirement 5**: Frontend — lazy load heavy components: `MarkdownEditor`, `DiffViewer`, `TrendChart`. These should only load when the parent page mounts them.
- **Requirement 6**: Add loading spinners for page-level Suspense fallbacks and skeleton screens for data cards (repo cards on Dashboard, analysis summary tables).
- **Requirement 7**: Create a reusable `<Spinner>` component and a `<SkeletonCard>` component for consistent loading states.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Performance Optimization

  Scenario: File scanner respects max file limit
    Given a repository with 10,000 source files
    And maxFileLimit is set to 5000
    When the file scanner runs
    Then it processes at most 5000 files
    And the result includes a "truncated: true" flag

  Scenario: File scanner skips binary files
    Given a repository with 100 .ts files and 50 .png files and 20 .zip files
    When the file scanner runs
    Then only the 100 .ts files are processed
    And .png and .zip files are not counted

  Scenario: Analyzer check timeout
    Given a complexity check that takes 45 seconds
    And the per-check timeout is 30 seconds
    When the analysis runs
    Then the complexity check is marked as "TIMEOUT"
    And other checks still complete normally
    And the analysis does not fail entirely

  Scenario: Git operation timeout
    Given a git diff operation that hangs
    And the git timeout is 30 seconds
    When the diff is requested
    Then the operation is aborted after 30 seconds
    And an error is returned to the caller

  Scenario: Pages are lazy loaded
    Given the user navigates to the Dashboard
    When the JavaScript bundle is inspected
    Then Dashboard code is in a separate chunk
    And it was not loaded with the initial bundle

  Scenario: Loading spinner during page load
    Given a page is being lazy loaded
    When the user navigates to that page
    Then a loading spinner is displayed
    And it disappears when the page finishes loading

  Scenario: Skeleton screens during data fetch
    Given the Dashboard page is loaded
    When repo data is being fetched from the API
    Then skeleton cards are displayed in place of repo cards
    And they are replaced with real data when the fetch completes
```

### 2.2 Verification Steps
- [ ] File scanner stops at `maxFileLimit` and sets `truncated: true`.
- [ ] Binary file extensions are skipped by the scanner.
- [ ] Analyzer checks that exceed 30s are marked `"TIMEOUT"` instead of crashing.
- [ ] Git operations abort after their configured timeout.
- [ ] Vite build output shows separate chunks for each lazy-loaded page.
- [ ] Navigating to any page shows a spinner if the chunk hasn't loaded yet.
- [ ] Dashboard shows skeleton cards while repo data is loading.
- [ ] No TypeScript compilation errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**:
  - `src/server/analyzer/engine.ts` (modify — add per-check timeout)
  - `src/server/git/scanner.ts` (modify — add binary file skip, file limit config)
  - `src/server/git/diff.ts` (modify — add git operation timeout)
  - `src/server/git/history.ts` (modify — add git operation timeout)
  - `src/client/App.tsx` (modify — lazy load pages)
  - `src/client/pages/Dashboard.tsx` (modify — add skeleton screens)
  - `src/client/components/Spinner.tsx` (create)
  - `src/client/components/SkeletonCard.tsx` (create)
- **Related Files**:
  - `src/server/utils/exec.ts` (may need timeout support for child_process)
  - `src/server/db/queries.ts` (read maxFileLimit from config)
- **New Files Needed**:
  - `src/client/components/Spinner.tsx`
  - `src/client/components/SkeletonCard.tsx`

### 3.2 Technical Logic

**Step 1: Define binary file extensions to skip**

```typescript
// src/server/git/scanner.ts — add near top of file

export const BINARY_EXTENSIONS = new Set([
  '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.svg', '.webp',
  '.woff', '.woff2', '.ttf', '.eot', '.otf',
  '.mp3', '.mp4', '.avi', '.mov', '.wav', '.flac',
  '.zip', '.tar', '.gz', '.bz2', '.7z', '.rar',
  '.exe', '.dll', '.so', '.dylib', '.bin',
  '.pdf', '.doc', '.docx', '.xls', '.xlsx',
  '.lock', '.map', '.min.js', '.min.css',
  '.db', '.sqlite', '.sqlite3',
]);

function isBinaryFile(filename: string): boolean {
  const ext = path.extname(filename).toLowerCase();
  return BINARY_EXTENSIONS.has(ext);
}
```

**Step 2: Add configurable max file limit to scanner**

```typescript
// src/server/git/scanner.ts — modify the file walking function

import { getConfig } from '../db/queries.js';

const DEFAULT_MAX_FILE_LIMIT = 5000;

export async function scanRepoFiles(
  repoPath: string,
  options?: { maxFiles?: number }
): Promise<{ files: string[]; truncated: boolean }> {
  // Read from config table, or use option override, or default
  const configLimit = getConfig('maxFileLimit');
  const maxFiles = options?.maxFiles
    ?? (configLimit ? parseInt(configLimit, 10) : DEFAULT_MAX_FILE_LIMIT);

  const files: string[] = [];
  let truncated = false;

  async function walk(dir: string): Promise<void> {
    if (files.length >= maxFiles) {
      truncated = true;
      return;
    }

    let entries;
    try {
      entries = await readdir(dir, { withFileTypes: true });
    } catch {
      return; // permission denied, skip
    }

    for (const entry of entries) {
      if (files.length >= maxFiles) {
        truncated = true;
        return;
      }

      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (SKIP_DIRS.has(entry.name)) continue;
        await walk(fullPath);
      } else if (entry.isFile()) {
        if (isBinaryFile(entry.name)) continue;
        files.push(fullPath);
      }
    }
  }

  await walk(repoPath);
  return { files, truncated };
}
```

**Step 3: Add per-check timeout to the analyzer engine**

```typescript
// src/server/analyzer/engine.ts — modify runChecks

export interface CheckResult {
  check: string;
  status: 'PASS' | 'WARN' | 'FAIL' | 'TIMEOUT';
  details: any;
  durationMs: number;
}

const DEFAULT_CHECK_TIMEOUT_MS = 30_000;

async function runCheckWithTimeout(
  checkName: string,
  checkFn: () => Promise<any>,
  timeoutMs = DEFAULT_CHECK_TIMEOUT_MS
): Promise<CheckResult> {
  const start = Date.now();

  try {
    const result = await Promise.race([
      checkFn(),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error(`Check '${checkName}' timed out after ${timeoutMs}ms`)),
          timeoutMs
        )
      ),
    ]);

    return {
      check: checkName,
      status: result.status,
      details: result.details,
      durationMs: Date.now() - start,
    };
  } catch (error) {
    const isTimeout = error instanceof Error && error.message.includes('timed out');
    return {
      check: checkName,
      status: isTimeout ? 'TIMEOUT' : 'FAIL',
      details: isTimeout
        ? { reason: `Exceeded ${timeoutMs}ms timeout` }
        : { reason: (error as Error).message },
      durationMs: Date.now() - start,
    };
  }
}

// In the main runAnalysis function, replace direct check calls:
export async function runAnalysis(repoPath: string, options: AnalysisOptions) {
  const checks = [
    { name: 'complexity', fn: () => runComplexityCheck(repoPath, options) },
    { name: 'duplication', fn: () => runDuplicationCheck(repoPath, options) },
    { name: 'error-patterns', fn: () => runErrorPatternCheck(repoPath, options) },
    { name: 'file-size', fn: () => runFileSizeCheck(repoPath, options) },
    { name: 'coupling', fn: () => runCouplingCheck(repoPath, options) },
    { name: 'dependencies', fn: () => runDependencyCheck(repoPath, options) },
  ];

  const results = await Promise.all(
    checks.map(({ name, fn }) => runCheckWithTimeout(name, fn))
  );

  return results;
}
```

**Step 4: Add timeouts to git operations**

```typescript
// src/server/utils/exec.ts — add timeout-aware exec wrapper

import { execFile, ChildProcess } from 'node:child_process';

export interface ExecOptions {
  cwd?: string;
  timeoutMs?: number;
}

export function execWithTimeout(
  command: string,
  args: string[],
  options: ExecOptions = {}
): Promise<string> {
  const { cwd, timeoutMs = 30_000 } = options;

  return new Promise((resolve, reject) => {
    const child: ChildProcess = execFile(
      command,
      args,
      { cwd, maxBuffer: 10 * 1024 * 1024 },
      (error, stdout, stderr) => {
        if (error) {
          if (error.killed) {
            reject(new Error(`Command '${command}' timed out after ${timeoutMs}ms`));
          } else {
            reject(error);
          }
        } else {
          resolve(stdout);
        }
      }
    );

    // Kill the process after timeout
    const timer = setTimeout(() => {
      child.kill('SIGTERM');
    }, timeoutMs);

    child.on('exit', () => clearTimeout(timer));
  });
}
```

```typescript
// src/server/git/scanner.ts — use timeout for git commands

import { execWithTimeout } from '../utils/exec.js';

const GIT_LIST_TIMEOUT_MS = 10_000;

export async function listBranches(repoPath: string): Promise<string[]> {
  const output = await execWithTimeout(
    'git',
    ['branch', '--list', '--format=%(refname:short)'],
    { cwd: repoPath, timeoutMs: GIT_LIST_TIMEOUT_MS }
  );
  return output.trim().split('\n').filter(Boolean);
}

// src/server/git/diff.ts — use timeout for diff commands

const GIT_DIFF_TIMEOUT_MS = 30_000;

export async function getDiff(
  repoPath: string,
  baseBranch: string,
  targetBranch: string
): Promise<string> {
  return execWithTimeout(
    'git',
    ['diff', `${baseBranch}...${targetBranch}`],
    { cwd: repoPath, timeoutMs: GIT_DIFF_TIMEOUT_MS }
  );
}
```

**Step 5: Lazy load pages in App.tsx**

```tsx
// src/client/App.tsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { Spinner } from './components/Spinner';
import { ErrorBoundary } from './components/ErrorBoundary';
import { ToastProvider } from './components/Toast';

// Lazy load all pages
const Dashboard = lazy(() => import('./pages/Dashboard'));
const SkillsEditor = lazy(() => import('./pages/SkillsEditor'));
const RulesEditor = lazy(() => import('./pages/RulesEditor'));
const AnalysisView = lazy(() => import('./pages/AnalysisView'));
const PRNavigator = lazy(() => import('./pages/PRNavigator'));
const Trends = lazy(() => import('./pages/Trends'));
const DocsStatus = lazy(() => import('./pages/DocsStatus'));
const Settings = lazy(() => import('./pages/Settings'));

function App() {
  return (
    <ErrorBoundary>
      <ToastProvider>
        <BrowserRouter>
          <Suspense fallback={<PageSpinner />}>
            <Routes>
              <Route path="/" element={<Dashboard />} />
              <Route path="/skills" element={<SkillsEditor />} />
              <Route path="/rules" element={<RulesEditor />} />
              <Route path="/analysis/:repoId" element={<AnalysisView />} />
              <Route path="/branches/:repoId" element={<PRNavigator />} />
              <Route path="/trends/:repoId" element={<Trends />} />
              <Route path="/docs/:repoId" element={<DocsStatus />} />
              <Route path="/settings" element={<Settings />} />
            </Routes>
          </Suspense>
        </BrowserRouter>
      </ToastProvider>
    </ErrorBoundary>
  );
}

function PageSpinner() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <Spinner size="lg" />
    </div>
  );
}

export default App;
```

Note: Each page component must use `export default` for `React.lazy()` to work.

**Step 6: Lazy load heavy components within pages**

```tsx
// Inside src/client/pages/AnalysisView.tsx (or any page using heavy components)
import React, { Suspense, lazy } from 'react';
import { Spinner } from '../components/Spinner';

const MarkdownEditor = lazy(() => import('../components/MarkdownEditor'));
const DiffViewer = lazy(() => import('../components/DiffViewer'));

function AnalysisView() {
  return (
    <div>
      {/* ... */}
      <Suspense fallback={<Spinner />}>
        <DiffViewer diff={diffData} />
      </Suspense>
    </div>
  );
}
```

```tsx
// Inside src/client/pages/Trends.tsx
const TrendChart = lazy(() => import('../components/TrendChart'));
```

**Step 7: Create Spinner and SkeletonCard components**

```tsx
// src/client/components/Spinner.tsx
import React from 'react';

interface SpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export function Spinner({ size = 'md', className = '' }: SpinnerProps) {
  const sizeClasses = {
    sm: 'h-4 w-4 border-2',
    md: 'h-8 w-8 border-2',
    lg: 'h-12 w-12 border-3',
  };

  return (
    <div
      className={`animate-spin rounded-full border-gray-300 border-t-blue-600 ${sizeClasses[size]} ${className}`}
      role="status"
      aria-label="Loading"
    />
  );
}
```

```tsx
// src/client/components/SkeletonCard.tsx
import React from 'react';

interface SkeletonCardProps {
  lines?: number;
  className?: string;
}

export function SkeletonCard({ lines = 3, className = '' }: SkeletonCardProps) {
  return (
    <div className={`bg-white rounded-lg shadow p-6 animate-pulse ${className}`}>
      <div className="h-5 bg-gray-200 rounded w-3/4 mb-4" />
      {Array.from({ length: lines }).map((_, i) => (
        <div
          key={i}
          className="h-3 bg-gray-200 rounded mb-2"
          style={{ width: `${100 - i * 15}%` }}
        />
      ))}
    </div>
  );
}
```

### 3.3 API Contract

No new endpoints. Behavioral changes to existing operations:

- **File scanning**: results may include `truncated: true` if file limit was reached.
- **Analysis**: individual check results may have `status: "TIMEOUT"` if they exceeded 30s.
- **Git operations**: may return timeout errors if git commands exceed their limits.

---

## 4. Definition of Done (The Gate)
- [ ] File scanner respects `maxFileLimit` (default 5000) and skips binary extensions.
- [ ] Analyzer engine wraps each check in a timeout (default 30s); timed-out checks report `"TIMEOUT"`.
- [ ] Git operations use `execWithTimeout` with 10s (listing) and 30s (diffs) limits.
- [ ] All page components in `App.tsx` are lazy loaded via `React.lazy()` + `Suspense`.
- [ ] `MarkdownEditor`, `DiffViewer`, and `TrendChart` are lazy loaded in their parent pages.
- [ ] `Spinner.tsx` and `SkeletonCard.tsx` components exist.
- [ ] A full-page spinner appears during page chunk loading.
- [ ] Skeleton cards appear on Dashboard while data is fetching.
- [ ] Vite build produces separate chunks for each lazy-loaded page (verify with `vite build`).
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
