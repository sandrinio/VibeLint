---
id: STORY-009-01
parent_epic: EPIC-009
status: Draft
actor: Full-Stack Developer
complexity: High (4+ files)
---
# STORY-009-01: Error Handling Audit

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Full-Stack Developer,
**I want** consistent error handling across all Fastify API routes, a global error handler, a React error boundary, and a toast notification system for transient errors,
**So that** users never see raw stack traces, the server never crashes from unhandled exceptions, and the frontend gracefully recovers from both rendering errors and failed API calls.

### 1.2 Detailed Requirements
- **Requirement 1**: Define a standard error response format used by every API endpoint: `{ error: string, code: string, details?: any }`. All 4xx and 5xx responses must conform to this shape.
- **Requirement 2**: Audit every route handler in `src/server/api/*.ts` (repos.ts, skills.ts, rules.ts, commands.ts, analysis.ts, inject.ts, trends.ts, docs.ts, config.ts). Wrap each handler body in try/catch. Return appropriate HTTP status codes (400 for bad input, 404 for not found, 409 for conflicts, 500 for unexpected errors).
- **Requirement 3**: Register a Fastify `setErrorHandler` hook that catches any unhandled errors, logs the full stack trace to the server console, and returns a generic 500 response `{ error: "Internal server error", code: "INTERNAL_ERROR" }` to the client. Never expose stack traces in HTTP responses.
- **Requirement 4**: Create `src/client/components/ErrorBoundary.tsx` — a React error boundary component that catches rendering errors anywhere in the component tree. Display a user-friendly message ("Something went wrong") with a "Reload" button that calls `window.location.reload()`.
- **Requirement 5**: Wrap the entire app in `<ErrorBoundary>` in `src/client/App.tsx`.
- **Requirement 6**: Create a toast/notification system for transient API errors. When any API call from `src/client/lib/api.ts` fails, display a dismissible toast with the error message. Toasts auto-dismiss after 5 seconds.
- **Requirement 7**: Create a shared error utility module `src/server/utils/errors.ts` that exports helper functions for creating typed error responses (e.g., `notFound()`, `badRequest()`, `conflict()`, `internalError()`).

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Error Handling Audit

  Scenario: API returns structured error for invalid input
    Given the Fastify server is running
    When I send a POST to /api/repos with an empty body
    Then the response status is 400
    And the response body matches { "error": "...", "code": "BAD_REQUEST" }

  Scenario: API returns 404 for missing resource
    Given the Fastify server is running
    When I send a GET to /api/repos/nonexistent-id
    Then the response status is 404
    And the response body matches { "error": "...", "code": "NOT_FOUND" }

  Scenario: Unhandled error returns generic 500
    Given a route handler throws an unexpected Error
    When the request is processed
    Then the response status is 500
    And the response body is { "error": "Internal server error", "code": "INTERNAL_ERROR" }
    And the stack trace is logged to the server console
    And the stack trace is NOT in the response body

  Scenario: React error boundary catches rendering crash
    Given a child component throws during render
    When the ErrorBoundary catches the error
    Then the fallback UI is displayed with "Something went wrong"
    And a "Reload" button is visible

  Scenario: Toast notification on API failure
    Given the user is on the Dashboard page
    When an API call to /api/repos fails with a network error
    Then a toast notification appears with the error message
    And the toast auto-dismisses after 5 seconds

  Scenario: Toast can be manually dismissed
    Given a toast is visible
    When the user clicks the dismiss button on the toast
    Then the toast is removed immediately
```

### 2.2 Verification Steps
- [ ] Every route handler in `src/server/api/*.ts` has try/catch wrapping the handler body.
- [ ] All error responses conform to `{ error: string, code: string, details?: any }`.
- [ ] Fastify `setErrorHandler` is registered in `src/server/index.ts`.
- [ ] Triggering an unhandled error returns 500 with generic message (no stack trace in body).
- [ ] `ErrorBoundary.tsx` renders fallback UI when a child component throws.
- [ ] `App.tsx` wraps routes in `<ErrorBoundary>`.
- [ ] API client in `src/client/lib/api.ts` triggers toast on failure.
- [ ] Toasts appear, auto-dismiss after 5s, and can be manually dismissed.
- [ ] No TypeScript compilation errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**:
  - `src/server/utils/errors.ts` (create)
  - `src/server/index.ts` (modify — add error handler hook)
  - `src/server/api/repos.ts` (modify — add try/catch)
  - `src/server/api/skills.ts` (modify — add try/catch)
  - `src/server/api/rules.ts` (modify — add try/catch)
  - `src/server/api/commands.ts` (modify — add try/catch)
  - `src/server/api/analysis.ts` (modify — add try/catch)
  - `src/server/api/inject.ts` (modify — add try/catch)
  - `src/server/api/trends.ts` (modify — add try/catch)
  - `src/server/api/docs.ts` (modify — add try/catch)
  - `src/server/api/config.ts` (modify — add try/catch)
  - `src/client/components/ErrorBoundary.tsx` (create)
  - `src/client/components/Toast.tsx` (create)
  - `src/client/App.tsx` (modify — wrap with ErrorBoundary)
  - `src/client/lib/api.ts` (modify — add error interception + toast)
- **Related Files**: None
- **New Files Needed**:
  - `src/server/utils/errors.ts`
  - `src/client/components/ErrorBoundary.tsx`
  - `src/client/components/Toast.tsx`

### 3.2 Technical Logic

**Step 1: Create the error utility module**

```typescript
// src/server/utils/errors.ts

export interface ApiErrorResponse {
  error: string;
  code: string;
  details?: any;
}

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public code: string,
    message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }

  toResponse(): ApiErrorResponse {
    return {
      error: this.message,
      code: this.code,
      ...(this.details !== undefined && { details: this.details }),
    };
  }
}

export function badRequest(message: string, details?: any): ApiError {
  return new ApiError(400, 'BAD_REQUEST', message, details);
}

export function notFound(resource: string, id?: string): ApiError {
  const msg = id ? `${resource} '${id}' not found` : `${resource} not found`;
  return new ApiError(404, 'NOT_FOUND', msg);
}

export function conflict(message: string, details?: any): ApiError {
  return new ApiError(409, 'CONFLICT', message, details);
}

export function internalError(message = 'Internal server error'): ApiError {
  return new ApiError(500, 'INTERNAL_ERROR', message);
}
```

**Step 2: Register the Fastify global error handler**

```typescript
// src/server/index.ts — add after Fastify instance creation

import { ApiError } from './utils/errors.js';

server.setErrorHandler((error, request, reply) => {
  // If it's a known ApiError, return structured response
  if (error instanceof ApiError) {
    return reply.status(error.statusCode).send(error.toResponse());
  }

  // Fastify validation errors (from JSON schema validation)
  if (error.validation) {
    return reply.status(400).send({
      error: 'Validation error',
      code: 'VALIDATION_ERROR',
      details: error.validation,
    });
  }

  // Unknown / unhandled error — log stack trace, return generic 500
  console.error('[UNHANDLED ERROR]', error.stack || error);
  return reply.status(500).send({
    error: 'Internal server error',
    code: 'INTERNAL_ERROR',
  });
});
```

**Step 3: Audit and wrap each route handler**

Apply the following pattern to every route handler in `src/server/api/*.ts`. Example for repos.ts:

```typescript
// src/server/api/repos.ts — BEFORE (example)
server.get('/api/repos/:repoId', async (request, reply) => {
  const { repoId } = request.params as { repoId: string };
  const repo = db.getRepo(repoId);
  return reply.send(repo);
});

// src/server/api/repos.ts — AFTER (example)
import { badRequest, notFound } from '../utils/errors.js';

server.get('/api/repos/:repoId', async (request, reply) => {
  const { repoId } = request.params as { repoId: string };

  if (!repoId) {
    throw badRequest('repoId is required');
  }

  const repo = db.getRepo(repoId);
  if (!repo) {
    throw notFound('Repository', repoId);
  }

  return reply.send(repo);
});
```

Apply this pattern across all handlers:
- **POST** routes: validate required body fields, throw `badRequest()` if missing.
- **GET with :id**: throw `notFound()` if resource doesn't exist.
- **PUT/DELETE with :id**: throw `notFound()` if resource doesn't exist.
- Let any unexpected errors propagate to the global `setErrorHandler`.

For each file in `src/server/api/`, follow this checklist:
1. Import `badRequest`, `notFound`, `conflict` from `../utils/errors.js`.
2. Add input validation at the top of each handler (check params, body).
3. Check for resource existence before operating.
4. Remove any bare `reply.status(500).send(...)` calls — let the global handler catch unhandled errors.

**Step 4: Create the React ErrorBoundary**

```tsx
// src/client/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('[ErrorBoundary] Caught error:', error, errorInfo);
  }

  handleReload = (): void => {
    window.location.reload();
  };

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 p-8">
          <div className="bg-white rounded-lg shadow-lg p-8 max-w-md text-center">
            <h1 className="text-2xl font-bold text-gray-900 mb-4">
              Something went wrong
            </h1>
            <p className="text-gray-600 mb-6">
              An unexpected error occurred. Please try reloading the page.
            </p>
            {this.state.error && (
              <p className="text-sm text-gray-400 mb-4 font-mono break-all">
                {this.state.error.message}
              </p>
            )}
            <button
              onClick={this.handleReload}
              className="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
            >
              Reload
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**Step 5: Create the Toast notification system**

```tsx
// src/client/components/Toast.tsx
import React, { useEffect, useState, useCallback, createContext, useContext } from 'react';

export interface ToastMessage {
  id: string;
  message: string;
  type: 'error' | 'success' | 'info';
  duration?: number; // ms, default 5000
}

interface ToastContextValue {
  addToast: (message: string, type?: ToastMessage['type'], duration?: number) => void;
  removeToast: (id: string) => void;
}

const ToastContext = createContext<ToastContextValue | null>(null);

export function useToast(): ToastContextValue {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);

  const addToast = useCallback(
    (message: string, type: ToastMessage['type'] = 'error', duration = 5000) => {
      const id = `toast-${Date.now()}-${Math.random().toString(36).slice(2)}`;
      setToasts((prev) => [...prev, { id, message, type, duration }]);
    },
    []
  );

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ addToast, removeToast }}>
      {children}
      <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2">
        {toasts.map((toast) => (
          <ToastItem
            key={toast.id}
            toast={toast}
            onDismiss={() => removeToast(toast.id)}
          />
        ))}
      </div>
    </ToastContext.Provider>
  );
}

function ToastItem({
  toast,
  onDismiss,
}: {
  toast: ToastMessage;
  onDismiss: () => void;
}) {
  useEffect(() => {
    const timer = setTimeout(onDismiss, toast.duration ?? 5000);
    return () => clearTimeout(timer);
  }, [toast.duration, onDismiss]);

  const bgColor =
    toast.type === 'error'
      ? 'bg-red-600'
      : toast.type === 'success'
        ? 'bg-green-600'
        : 'bg-blue-600';

  return (
    <div
      className={`${bgColor} text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-3 min-w-[300px] max-w-md animate-slide-in`}
    >
      <span className="flex-1 text-sm">{toast.message}</span>
      <button
        onClick={onDismiss}
        className="text-white/80 hover:text-white text-lg leading-none"
        aria-label="Dismiss"
      >
        &times;
      </button>
    </div>
  );
}
```

**Step 6: Wrap App with ErrorBoundary and ToastProvider**

```tsx
// src/client/App.tsx — modify the root render
import { ErrorBoundary } from './components/ErrorBoundary';
import { ToastProvider } from './components/Toast';

function App() {
  return (
    <ErrorBoundary>
      <ToastProvider>
        {/* existing Router / Routes / layout */}
      </ToastProvider>
    </ErrorBoundary>
  );
}
```

**Step 7: Integrate toast with the API client**

```typescript
// src/client/lib/api.ts — add error interception

// At module level, store a reference to the toast function
let toastFn: ((message: string, type?: 'error' | 'success' | 'info') => void) | null = null;

export function setToastFunction(
  fn: (message: string, type?: 'error' | 'success' | 'info') => void
): void {
  toastFn = fn;
}

// Wrap fetch calls to intercept errors
async function apiFetch<T>(url: string, options?: RequestInit): Promise<T> {
  try {
    const response = await fetch(url, {
      headers: { 'Content-Type': 'application/json' },
      ...options,
    });

    if (!response.ok) {
      const body = await response.json().catch(() => null);
      const message = body?.error || `Request failed (${response.status})`;
      if (toastFn) {
        toastFn(message, 'error');
      }
      throw new Error(message);
    }

    return response.json() as Promise<T>;
  } catch (error) {
    if (error instanceof TypeError && error.message.includes('fetch')) {
      // Network error (server unreachable)
      const msg = 'Cannot connect to VibeLint server. Is it running?';
      if (toastFn) {
        toastFn(msg, 'error');
      }
      throw new Error(msg);
    }
    throw error;
  }
}
```

Then in `App.tsx`, initialize the toast integration:

```tsx
// In App component body
import { useToast } from './components/Toast';
import { setToastFunction } from './lib/api';

function AppContent() {
  const { addToast } = useToast();

  useEffect(() => {
    setToastFunction(addToast);
  }, [addToast]);

  return (
    // existing routes and layout
  );
}
```

### 3.3 API Contract

All existing endpoints remain the same. The only change is the response shape on errors:

**Error Response Format (all endpoints)**
```
Status: 400 | 404 | 409 | 500
Content-Type: application/json

{
  "error": "Human-readable error message",
  "code": "BAD_REQUEST" | "NOT_FOUND" | "CONFLICT" | "VALIDATION_ERROR" | "INTERNAL_ERROR",
  "details": <optional — validation details or additional context>
}
```

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/utils/errors.ts` exists and exports `ApiError`, `badRequest()`, `notFound()`, `conflict()`, `internalError()`.
- [ ] Every route handler in `src/server/api/*.ts` validates input and returns structured error responses.
- [ ] Fastify `setErrorHandler` is registered in `src/server/index.ts`.
- [ ] Unhandled errors return 500 with `{ error: "Internal server error", code: "INTERNAL_ERROR" }` — no stack traces in response.
- [ ] Stack traces are logged to server console for unhandled errors.
- [ ] `src/client/components/ErrorBoundary.tsx` exists and renders fallback UI on render errors.
- [ ] `App.tsx` wraps the application in `<ErrorBoundary>`.
- [ ] `src/client/components/Toast.tsx` exists with `ToastProvider` and `useToast` hook.
- [ ] API failures trigger toast notifications in the UI.
- [ ] Toasts auto-dismiss after 5 seconds and can be manually dismissed.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
