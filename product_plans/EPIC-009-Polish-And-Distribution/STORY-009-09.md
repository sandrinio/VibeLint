---
id: STORY-009-09
parent_epic: EPIC-009
status: Draft
actor: Full-Stack Developer
complexity: High (4+ files)
---
# STORY-009-09: Version Check & Update Notification

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** VibeLint user,
**I want** to be notified when a new version is available and be able to update easily,
**So that** I always have the latest features and bug fixes without manually checking npm.

### 1.2 Detailed Requirements
- **Requirement 1**: Read the current version from `package.json` at startup. Never hardcode version strings.
- **Requirement 2**: On server startup, check the npm registry for the latest published version of `vibelint`. Use `https://registry.npmjs.org/vibelint/latest` (simple GET, no auth needed). Cache the result for 24 hours in the config table (`config.latest_version_check`).
- **Requirement 3**: Create `GET /api/version` endpoint returning `{ current: string, latest: string | null, updateAvailable: boolean }`.
- **Requirement 4**: CLI startup message — when the server starts, if an update is available, print: `Update available: 0.1.0 → 0.2.0. Run "npm install -g vibelint" to update.` in the terminal. Use chalk/color for visibility (yellow text).
- **Requirement 5**: UI notification banner — when the frontend detects `updateAvailable: true` from `/api/version`, show a dismissable banner at the top of the page: "VibeLint v{latest} is available. You're on v{current}." with an "Update" button and a dismiss (×) button. Banner should persist across page navigations until dismissed (store dismiss state in sessionStorage, not localStorage — reappears next session).
- **Requirement 6**: Add `vibelint update` CLI subcommand that runs `npm install -g vibelint@latest` via `child_process.execFile`. Show a spinner/progress indicator while updating. On success, print the new version. On failure, show the npm error output.
- **Requirement 7**: Settings page — add a "Version" section showing current version, latest version, and an "Check for Updates" button that re-fetches from npm (bypassing cache). If update available, show an "Update Now" button that triggers the same update flow as the CLI command (via `POST /api/version/update`).
- **Requirement 8**: `POST /api/version/update` endpoint — executes `npm install -g vibelint@latest`, streams stdout/stderr back as the response. Returns `{ success: boolean, newVersion: string, output: string }`. **Important**: This endpoint must validate that vibelint was installed globally (not run from source/dev) before attempting the update.
- **Requirement 9**: Gracefully handle offline/network-error scenarios — if the npm registry check fails, log it and continue. Never block startup or crash due to a failed version check.
- **Requirement 10**: Use `semver.compare()` (from the `semver` npm package) for version comparison, not string comparison.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Version Check & Update Notification

  Scenario: Version endpoint returns current and latest versions
    Given the server is running version "0.1.0"
    And the npm registry reports latest version "0.2.0"
    When I send GET /api/version
    Then the response status is 200
    And the response body is { "current": "0.1.0", "latest": "0.2.0", "updateAvailable": true }

  Scenario: No update available
    Given the server is running version "0.2.0"
    And the npm registry reports latest version "0.2.0"
    When I send GET /api/version
    Then the response body has updateAvailable false

  Scenario: CLI shows update notification on startup
    Given the server is running version "0.1.0"
    And the npm registry reports latest version "0.2.0"
    When the server starts
    Then the terminal output includes "Update available: 0.1.0 → 0.2.0"

  Scenario: CLI update command works
    Given vibelint is installed globally
    When the user runs "vibelint update"
    Then npm install -g vibelint@latest is executed
    And the new version is printed on success

  Scenario: UI banner appears when update is available
    Given the frontend loads and GET /api/version returns updateAvailable true
    When the page renders
    Then a notification banner is visible at the top of the page
    And it shows the current and latest version numbers

  Scenario: UI banner can be dismissed
    Given the update banner is visible
    When the user clicks the dismiss button
    Then the banner is hidden
    And it does not reappear during this browser session

  Scenario: UI banner reappears in new session
    Given the user dismissed the banner in a previous session
    When the user opens VibeLint in a new browser session
    Then the banner reappears if an update is still available

  Scenario: Offline graceful degradation
    Given the npm registry is unreachable
    When the server starts
    Then the server starts successfully without error
    And GET /api/version returns { "current": "0.1.0", "latest": null, "updateAvailable": false }

  Scenario: Version check result is cached for 24 hours
    Given a successful version check was performed 1 hour ago
    When GET /api/version is called
    Then the cached result is returned without hitting the npm registry

  Scenario: Force refresh from Settings
    Given a cached version check exists
    When the user clicks "Check for Updates" in Settings
    Then GET /api/version?force=true is called
    And the npm registry is queried fresh
```

### 2.2 Verification Steps
- [ ] `GET /api/version` returns correct `current`, `latest`, and `updateAvailable` fields.
- [ ] Server startup prints update notification when a newer version exists.
- [ ] `vibelint update` CLI command successfully updates the global package.
- [ ] UI banner appears when update is available and can be dismissed.
- [ ] Banner reappears in new browser sessions.
- [ ] Offline/network-error doesn't block startup or crash the server.
- [ ] Version check is cached for 24 hours; `?force=true` bypasses cache.
- [ ] Settings page shows version info and "Check for Updates" / "Update Now" buttons.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**:
  - `src/server/api/version.ts` (create — version endpoints)
  - `src/server/version/checker.ts` (create — npm registry check logic)
  - `src/client/components/UpdateBanner.tsx` (create — notification banner)
- **Related Files**:
  - `src/server/index.ts` (register version routes, startup check)
  - `src/cli/index.ts` (add `update` subcommand, startup notification)
  - `src/client/pages/Settings.tsx` (add version section)
  - `src/client/App.tsx` (mount UpdateBanner)
  - `src/client/lib/api.ts` (add version API calls)
  - `package.json` (add `semver` dependency)
- **New Files Needed**: `src/server/api/version.ts`, `src/server/version/checker.ts`, `src/client/components/UpdateBanner.tsx`

### 3.2 Technical Logic

**Step 1: Install dependencies**

```bash
npm install semver
npm install -D @types/semver
```

**Step 2: Create `src/server/version/checker.ts`**

```typescript
import { readFileSync } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { gt } from 'semver';
import { getConfig, setConfig } from '../db/queries.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Read version from package.json at module load time
const pkgPath = path.resolve(__dirname, '../../../package.json');
const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
export const CURRENT_VERSION: string = pkg.version;

const NPM_REGISTRY_URL = 'https://registry.npmjs.org/vibelint/latest';
const CACHE_KEY = 'latest_version_check';
const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

interface CachedCheck {
  latest: string;
  checkedAt: number;
}

export interface VersionInfo {
  current: string;
  latest: string | null;
  updateAvailable: boolean;
}

/**
 * Check for the latest version, using cache unless force=true.
 */
export async function checkLatestVersion(force = false): Promise<VersionInfo> {
  // Check cache first
  if (!force) {
    const cached = getConfig(CACHE_KEY);
    if (cached) {
      try {
        const parsed: CachedCheck = JSON.parse(cached);
        if (Date.now() - parsed.checkedAt < CACHE_TTL_MS) {
          return {
            current: CURRENT_VERSION,
            latest: parsed.latest,
            updateAvailable: gt(parsed.latest, CURRENT_VERSION),
          };
        }
      } catch {
        // Malformed cache, proceed with fresh check
      }
    }
  }

  // Fetch from npm registry
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000); // 5s timeout

    const response = await fetch(NPM_REGISTRY_URL, {
      signal: controller.signal,
      headers: { Accept: 'application/json' },
    });
    clearTimeout(timeout);

    if (!response.ok) {
      return { current: CURRENT_VERSION, latest: null, updateAvailable: false };
    }

    const data = (await response.json()) as { version: string };
    const latest = data.version;

    // Cache the result
    setConfig(CACHE_KEY, JSON.stringify({
      latest,
      checkedAt: Date.now(),
    }));

    return {
      current: CURRENT_VERSION,
      latest,
      updateAvailable: gt(latest, CURRENT_VERSION),
    };
  } catch {
    // Network error, offline, timeout — fail gracefully
    return { current: CURRENT_VERSION, latest: null, updateAvailable: false };
  }
}
```

**Step 3: Create `src/server/api/version.ts`**

```typescript
import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { checkLatestVersion, CURRENT_VERSION } from '../version/checker.js';

const execFileAsync = promisify(execFile);

export default async function versionRoutes(fastify: FastifyInstance): Promise<void> {
  // GET /api/version — current + latest version info
  fastify.get('/api/version', async (request: FastifyRequest) => {
    const force = (request.query as { force?: string }).force === 'true';
    return checkLatestVersion(force);
  });

  // POST /api/version/update — trigger self-update
  fastify.post('/api/version/update', async (_request: FastifyRequest, reply: FastifyReply) => {
    // Safety: verify this is a global npm install, not dev/source
    try {
      const { stdout: npmRoot } = await execFileAsync('npm', ['root', '-g']);
      const globalRoot = npmRoot.trim();

      // Check if vibelint is in the global node_modules
      const { stdout: lsOutput } = await execFileAsync('npm', ['ls', '-g', 'vibelint', '--json']);
      const lsData = JSON.parse(lsOutput);
      if (!lsData.dependencies?.vibelint) {
        return reply.status(400).send({
          success: false,
          error: 'VibeLint does not appear to be installed globally. Cannot self-update.',
        });
      }
    } catch {
      return reply.status(400).send({
        success: false,
        error: 'Could not verify global npm installation. Update manually with: npm install -g vibelint',
      });
    }

    // Run the update
    try {
      const { stdout, stderr } = await execFileAsync('npm', ['install', '-g', 'vibelint@latest'], {
        timeout: 120_000, // 2 minute timeout
      });

      // Get new version
      const { stdout: newVersionOutput } = await execFileAsync('npm', ['ls', '-g', 'vibelint', '--json']);
      const newData = JSON.parse(newVersionOutput);
      const newVersion = newData.dependencies?.vibelint?.version ?? 'unknown';

      return {
        success: true,
        previousVersion: CURRENT_VERSION,
        newVersion,
        output: stdout + stderr,
      };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Update failed';
      return reply.status(500).send({
        success: false,
        error: message,
      });
    }
  });
}
```

**Step 4: CLI startup notification (in `src/cli/index.ts`)**

After server starts successfully, add:

```typescript
import { checkLatestVersion } from '../server/version/checker.js';

// After server.listen() succeeds:
const versionInfo = await checkLatestVersion();
if (versionInfo.updateAvailable && versionInfo.latest) {
  console.log(
    `\n  Update available: ${versionInfo.current} → ${versionInfo.latest}` +
    `\n  Run "npm install -g vibelint" to update.\n`
  );
}
```

**Step 5: CLI `update` subcommand (in `src/cli/index.ts`)**

```typescript
// Parse CLI args before starting server:
const args = process.argv.slice(2);

if (args[0] === 'update') {
  console.log('Checking for updates...');
  const versionInfo = await checkLatestVersion(true);

  if (!versionInfo.updateAvailable) {
    console.log(`Already on the latest version (${versionInfo.current}).`);
    process.exit(0);
  }

  console.log(`Updating vibelint: ${versionInfo.current} → ${versionInfo.latest}...`);
  try {
    const { stdout, stderr } = await execFileAsync('npm', ['install', '-g', 'vibelint@latest']);
    console.log(stdout);
    if (stderr) console.error(stderr);
    console.log(`Successfully updated to ${versionInfo.latest}.`);
  } catch (err) {
    console.error('Update failed:', err instanceof Error ? err.message : err);
    process.exit(1);
  }
  process.exit(0);
}
```

**Step 6: Create `src/client/components/UpdateBanner.tsx`**

```tsx
import React, { useEffect, useState } from 'react';

interface VersionInfo {
  current: string;
  latest: string | null;
  updateAvailable: boolean;
}

export default function UpdateBanner() {
  const [versionInfo, setVersionInfo] = useState<VersionInfo | null>(null);
  const [dismissed, setDismissed] = useState(false);
  const [updating, setUpdating] = useState(false);

  useEffect(() => {
    // Check if already dismissed this session
    if (sessionStorage.getItem('vibelint-update-dismissed') === 'true') {
      setDismissed(true);
      return;
    }

    fetch('/api/version')
      .then((res) => res.json())
      .then((data: VersionInfo) => setVersionInfo(data))
      .catch(() => {}); // Fail silently
  }, []);

  const handleDismiss = () => {
    setDismissed(true);
    sessionStorage.setItem('vibelint-update-dismissed', 'true');
  };

  const handleUpdate = async () => {
    setUpdating(true);
    try {
      const res = await fetch('/api/version/update', { method: 'POST' });
      const data = await res.json();
      if (data.success) {
        alert(`Updated to v${data.newVersion}. Please restart VibeLint.`);
      } else {
        alert(`Update failed: ${data.error}`);
      }
    } catch {
      alert('Update failed. Run "npm install -g vibelint" manually.');
    } finally {
      setUpdating(false);
    }
  };

  if (dismissed || !versionInfo?.updateAvailable || !versionInfo.latest) {
    return null;
  }

  return (
    <div className="bg-amber-50 border-b border-amber-200 px-4 py-2 flex items-center justify-between text-sm">
      <span className="text-amber-800">
        VibeLint <strong>v{versionInfo.latest}</strong> is available.
        You're on v{versionInfo.current}.
      </span>
      <div className="flex items-center gap-2">
        <button
          onClick={handleUpdate}
          disabled={updating}
          className="text-amber-700 font-medium hover:text-amber-900 underline disabled:opacity-50"
        >
          {updating ? 'Updating...' : 'Update'}
        </button>
        <button
          onClick={handleDismiss}
          className="text-amber-400 hover:text-amber-600 ml-2"
          aria-label="Dismiss"
        >
          ×
        </button>
      </div>
    </div>
  );
}
```

**Step 7: Mount in `src/client/App.tsx`**

```tsx
import UpdateBanner from './components/UpdateBanner';

// At the top of the app layout, before routes:
<UpdateBanner />
```

**Step 8: Add version API calls to `src/client/lib/api.ts`**

```typescript
export interface VersionInfo {
  current: string;
  latest: string | null;
  updateAvailable: boolean;
}

export function fetchVersionInfo(force = false): Promise<VersionInfo> {
  const query = force ? '?force=true' : '';
  return fetchJson(`/version${query}`);
}

export function triggerUpdate(): Promise<{ success: boolean; newVersion?: string; error?: string }> {
  return fetchJson('/version/update', { method: 'POST' });
}
```

### 3.3 API Contract

| Method | Path                   | Request Body | Response (200)                                                          | Response (Error)        |
|--------|------------------------|--------------|-------------------------------------------------------------------------|-------------------------|
| GET    | `/api/version`         | N/A          | `{ "current": "0.1.0", "latest": "0.2.0", "updateAvailable": true }`  | N/A (always 200)        |
| GET    | `/api/version?force=true` | N/A       | Same as above, bypasses cache                                           | N/A                     |
| POST   | `/api/version/update`  | N/A          | `{ "success": true, "previousVersion": "0.1.0", "newVersion": "0.2.0" }` | `400` — not global install; `500` — update failed |

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/version/checker.ts` reads version from `package.json` (never hardcoded).
- [ ] `src/server/version/checker.ts` checks npm registry with 5s timeout and 24h cache.
- [ ] `GET /api/version` returns current, latest, and updateAvailable.
- [ ] `GET /api/version?force=true` bypasses cache and re-checks npm.
- [ ] `POST /api/version/update` runs `npm install -g vibelint@latest` (only for global installs).
- [ ] CLI prints update notification on startup when update available.
- [ ] `vibelint update` subcommand updates the global package.
- [ ] `UpdateBanner.tsx` shows when update available, dismissable per-session.
- [ ] Offline/network errors are handled gracefully — never blocks startup.
- [ ] `semver` is used for version comparison.
- [ ] Settings page shows version section with "Check for Updates" button.
- [ ] TypeScript compiles with no errors.
