---
id: STORY-008-02
parent_epic: EPIC-008
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-008-02: Trend Computation

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a trend computation module that queries metric snapshots, computes deltas between time periods, and determines directional indicators for each metric,
**So that** the Trends API can return meaningful comparison data and the frontend can display improvement/regression indicators.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `computeTrends(repoId: string, period: TrendPeriod): Promise<TrendData>` that queries `metrics_history` and computes deltas for each metric.
- **Requirement 2**: Support three periods: `7d` (week), `30d` (month), `90d` (quarter). The period defines how far back to look for the "previous" comparison point.
- **Requirement 3**: For each metric, compute: `current` (most recent snapshot value), `previous` (value from the snapshot closest to one period ago), `delta` (absolute difference), `deltaPercent` (percentage change), and `direction` (`up`, `down`, or `flat`).
- **Requirement 4**: Direction is `flat` if the delta is less than 1% change or if previous/current are both null. Direction is `up` if current > previous, `down` if current < previous.
- **Requirement 5**: Return a `history` array containing all snapshots within the selected period, suitable for charting.
- **Requirement 6**: Handle edge cases: fewer than 2 snapshots (return `insufficientData: true`), all null values for a metric (return null trend), and missing periods (return the best available comparison).
- **Requirement 7**: The "previous" value should be the snapshot closest to (but not newer than) `now - period`. If no exact match, use the nearest older snapshot.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Trend Computation

  Scenario: Compute weekly trends
    Given repo "repo-1" has a snapshot from today with avgComplexity 5.0
    And a snapshot from 7 days ago with avgComplexity 6.0
    When I call computeTrends("repo-1", "7d")
    Then avgComplexity trend has current: 5.0, previous: 6.0, delta: -1.0, deltaPercent: -16.7, direction: "down"

  Scenario: Compute monthly trends
    Given repo "repo-1" has snapshots spanning 30 days
    When I call computeTrends("repo-1", "30d")
    Then each metric has current, previous, delta, deltaPercent, and direction

  Scenario: Direction is flat for small changes
    Given current avgComplexity is 5.00 and previous is 4.98
    When I call computeTrends
    Then avgComplexity direction is "flat" (delta < 1%)

  Scenario: Insufficient data
    Given repo "repo-1" has only 1 snapshot
    When I call computeTrends("repo-1", "7d")
    Then the result has insufficientData: true
    And metrics array is empty or contains only current values

  Scenario: No snapshots at all
    Given repo "repo-1" has 0 snapshots
    When I call computeTrends("repo-1", "7d")
    Then the result has insufficientData: true

  Scenario: History array for charting
    Given repo "repo-1" has 5 snapshots in the last 30 days
    When I call computeTrends("repo-1", "30d")
    Then the history array contains 5 entries
    And each entry has timestamp and metrics

  Scenario: Null metric values
    Given the current snapshot has avgComplexity null (no complexity data)
    When I call computeTrends
    Then avgComplexity trend has current: null, previous: null, direction: "flat"
```

### 2.2 Verification Steps
- [ ] `computeTrends` correctly computes deltas for all 8 metrics.
- [ ] `7d`, `30d`, `90d` periods select the correct comparison snapshots.
- [ ] `direction` is `up` when current > previous, `down` when current < previous, `flat` when < 1% change.
- [ ] `deltaPercent` is calculated correctly (relative to previous value).
- [ ] `insufficientData` is true when fewer than 2 snapshots exist.
- [ ] `history` array contains all snapshots within the period.
- [ ] Null metrics are handled without errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/analyzer/trends.ts` (create)
- **Related Files**:
  - `src/server/analyzer/snapshots.ts` (STORY-008-01 — `getSnapshots`, `MetricSnapshot`, `MetricValues`)
- **New Files Needed**:
  - `src/server/analyzer/trends.ts`
  - `tests/analyzer/trends.test.ts` (unit tests)

### 3.2 Technical Logic

**Step 1: Define types**

```typescript
// src/server/analyzer/trends.ts

import { getSnapshots, MetricSnapshot, MetricValues } from './snapshots.js';

export type TrendPeriod = '7d' | '30d' | '90d';

export type TrendDirection = 'up' | 'down' | 'flat';

export interface MetricTrend {
  name: string;                       // Metric key name
  current: number | null;
  previous: number | null;
  delta: number | null;               // current - previous
  deltaPercent: number | null;        // ((current - previous) / previous) * 100
  direction: TrendDirection;
}

export interface TrendData {
  repoId: string;
  period: TrendPeriod;
  insufficientData: boolean;
  metrics: MetricTrend[];
  history: Array<{
    timestamp: string;
    metrics: MetricValues;
  }>;
}
```

**Step 2: Implement period-to-milliseconds conversion**

```typescript
const PERIOD_MS: Record<TrendPeriod, number> = {
  '7d':  7  * 24 * 60 * 60 * 1000,
  '30d': 30 * 24 * 60 * 60 * 1000,
  '90d': 90 * 24 * 60 * 60 * 1000,
};

function getPeriodStartDate(period: TrendPeriod): string {
  const ms = PERIOD_MS[period];
  return new Date(Date.now() - ms).toISOString();
}
```

**Step 3: Find the comparison snapshot**

```typescript
/**
 * Find the snapshot closest to (but not newer than) the target date.
 * Snapshots should be sorted by timestamp ascending.
 */
function findPreviousSnapshot(
  snapshots: MetricSnapshot[],
  targetDate: string
): MetricSnapshot | null {
  const targetTime = new Date(targetDate).getTime();

  let best: MetricSnapshot | null = null;
  for (const snap of snapshots) {
    const snapTime = new Date(snap.timestamp).getTime();
    if (snapTime <= targetTime) {
      best = snap; // Keep updating — since sorted ascending, the last one <= target is closest
    } else {
      break; // Past the target, stop looking
    }
  }
  return best;
}
```

**Step 4: Compute delta and direction for a single metric**

```typescript
const FLAT_THRESHOLD = 0.01; // 1% change threshold

function computeMetricTrend(
  name: string,
  current: number | null,
  previous: number | null
): MetricTrend {
  // Both null — flat
  if (current === null && previous === null) {
    return { name, current: null, previous: null, delta: null, deltaPercent: null, direction: 'flat' };
  }

  // One is null — treat as flat (can't compute meaningful delta)
  if (current === null || previous === null) {
    return { name, current, previous, delta: null, deltaPercent: null, direction: 'flat' };
  }

  const delta = current - previous;
  const deltaPercent = previous !== 0
    ? Math.round((delta / Math.abs(previous)) * 1000) / 10  // 1 decimal precision
    : (delta === 0 ? 0 : (delta > 0 ? 100 : -100));

  let direction: TrendDirection = 'flat';
  if (Math.abs(deltaPercent) >= FLAT_THRESHOLD * 100) {
    direction = delta > 0 ? 'up' : 'down';
  }

  return {
    name,
    current,
    previous,
    delta: Math.round(delta * 100) / 100,
    deltaPercent,
    direction,
  };
}
```

**Step 5: Implement the main `computeTrends` function**

```typescript
const METRIC_KEYS: (keyof MetricValues)[] = [
  'avgComplexity',
  'maxComplexity',
  'duplicationPercentage',
  'totalFiles',
  'totalLines',
  'avgFileSize',
  'errorPatternCount',
  'dependencyCount',
];

export function computeTrends(
  repoId: string,
  period: TrendPeriod
): TrendData {
  const periodStart = getPeriodStartDate(period);

  // Get all snapshots (we need some before the period for the "previous" comparison)
  const allSnapshots = getSnapshots(repoId);

  if (allSnapshots.length < 2) {
    return {
      repoId,
      period,
      insufficientData: true,
      metrics: [],
      history: allSnapshots.map(s => ({
        timestamp: s.timestamp,
        metrics: s.metrics,
      })),
    };
  }

  // Current = most recent snapshot
  const currentSnapshot = allSnapshots[allSnapshots.length - 1];

  // Previous = snapshot closest to one period ago
  const targetDate = getPeriodStartDate(period);
  const previousSnapshot = findPreviousSnapshot(allSnapshots, targetDate);

  // Compute trends for each metric
  const metricTrends: MetricTrend[] = METRIC_KEYS.map(key => {
    const currentVal = currentSnapshot.metrics[key];
    const previousVal = previousSnapshot?.metrics[key] ?? null;
    return computeMetricTrend(key, currentVal, previousVal);
  });

  // Build history array (snapshots within the period)
  const history = allSnapshots
    .filter(s => s.timestamp >= periodStart)
    .map(s => ({
      timestamp: s.timestamp,
      metrics: s.metrics,
    }));

  return {
    repoId,
    period,
    insufficientData: false,
    metrics: metricTrends,
    history,
  };
}
```

**Step 6: Add a convenience function for lightweight dashboard use**

```typescript
/**
 * Get just the direction indicators for key metrics (used by Dashboard trend badges).
 * Returns a minimal object for embedding in repo cards.
 */
export function getQuickTrends(
  repoId: string
): Record<string, TrendDirection> | null {
  const allSnapshots = getSnapshots(repoId);
  if (allSnapshots.length < 2) return null;

  const current = allSnapshots[allSnapshots.length - 1];
  // Compare against snapshot closest to 7 days ago
  const weekAgo = getPeriodStartDate('7d');
  const previous = findPreviousSnapshot(allSnapshots, weekAgo);
  if (!previous) return null;

  const result: Record<string, TrendDirection> = {};
  for (const key of METRIC_KEYS) {
    const trend = computeMetricTrend(key, current.metrics[key], previous.metrics[key]);
    result[key] = trend.direction;
  }
  return result;
}
```

### 3.3 API Contract
N/A — this is an internal module consumed by `src/server/api/trends.ts` (STORY-008-03). No HTTP endpoints.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/analyzer/trends.ts` exists and exports `computeTrends`, `getQuickTrends`, `TrendData`, `MetricTrend`, `TrendPeriod`, `TrendDirection`.
- [ ] `computeTrends` correctly computes deltas for all 8 metrics across `7d`, `30d`, `90d` periods.
- [ ] Direction is `up`/`down`/`flat` based on 1% threshold.
- [ ] `deltaPercent` is computed correctly relative to previous value.
- [ ] `insufficientData` is true when fewer than 2 snapshots exist.
- [ ] `history` array contains all snapshots within the selected period for charting.
- [ ] Null metric values are handled without errors (direction is `flat`).
- [ ] `getQuickTrends` returns a minimal direction map for dashboard use.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
