---
id: STORY-008-05
parent_epic: EPIC-008
status: Draft
actor: Frontend Developer
complexity: High (4+ files)
---
# STORY-008-05: Trends Page

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Frontend Developer,
**I want** a Trends page that displays a grid of line charts for all tracked metrics with delta badges, period selection, and a full-scan trigger button,
**So that** developers and tech leads can monitor code quality trends over time and capture fresh snapshots.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/client/pages/Trends.tsx` as a full page component routed at `/trends`.
- **Requirement 2**: Display a repo selector dropdown at the top (same pattern as PR Navigator) that fetches from `GET /api/repos`.
- **Requirement 3**: Display a period selector with three options: `7d` (Week), `30d` (Month), `90d` (Quarter). Default: `30d`.
- **Requirement 4**: Render a responsive grid (2-3 columns) of TrendChart components, one for each metric: Avg Complexity, Max Complexity, Duplication %, Total Files, Total Lines, Avg File Size, Error Patterns, Dependency Count.
- **Requirement 5**: Each chart card shows: a title, the current metric value, and a delta badge showing the change from the previous period. The delta badge is colored: green arrow-down for metrics where lower is better (complexity, duplication, errors), red arrow-up for those same metrics when they increase. For metrics where higher is not necessarily bad (total files, total lines), use neutral coloring.
- **Requirement 6**: Include a "Run Full Scan" button that triggers `POST /api/repos/:repoId/scan`, shows a loading state, and refreshes all charts on completion.
- **Requirement 7**: If fewer than 2 snapshots exist (insufficientData is true), display a friendly message: "Not enough data to show trends. Run a Full Scan to capture your first snapshot." with a prominent scan button.
- **Requirement 8**: Show a "Last scanned: [timestamp]" indicator below the repo selector.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Trends Page

  Scenario: Page loads with trend charts
    Given repo "repo-1" has 5 snapshots over 30 days
    When the user navigates to /trends
    Then the repo selector shows "repo-1"
    And the period selector defaults to "30d"
    And 8 TrendChart components render in a grid
    And each chart has a title, current value, and delta badge

  Scenario: Period selection changes charts
    Given the page is showing 30d trends
    When the user clicks "7d" (Week)
    Then the charts refresh with 7-day trend data
    And the delta badges update to reflect weekly changes

  Scenario: Delta badge colors
    Given avgComplexity went down by 10% (improvement)
    And duplicationPercentage went up by 5% (regression)
    When the page renders
    Then avgComplexity shows a green badge with down arrow
    And duplicationPercentage shows a red badge with up arrow

  Scenario: Run full scan
    Given the page is loaded
    When the user clicks "Run Full Scan"
    Then the button shows a loading spinner
    And POST /api/repos/:repoId/scan is called
    And upon success, all charts refresh with the new data point

  Scenario: Insufficient data
    Given repo "repo-1" has only 1 snapshot
    When the user navigates to /trends
    Then a message says "Not enough data to show trends."
    And a "Run Full Scan" button is prominently displayed

  Scenario: No snapshots at all
    Given repo "repo-1" has 0 snapshots
    When the user navigates to /trends
    Then a message says "Not enough data to show trends. Run a Full Scan to capture your first snapshot."

  Scenario: Switch repos
    Given repos "repo-1" and "repo-2" exist
    When the user switches to "repo-2"
    Then the charts refresh with data from "repo-2"

  Scenario: Last scanned indicator
    Given repo "repo-1" was last scanned at "Feb 23, 2026 2:30 PM"
    When the page renders
    Then "Last scanned: Feb 23, 2026 2:30 PM" is displayed
```

### 2.2 Verification Steps
- [ ] Page loads at `/trends` route without errors.
- [ ] Repo selector populates from API and triggers chart refresh on change.
- [ ] Period selector (7d, 30d, 90d) updates charts when changed.
- [ ] 8 TrendChart components render in a responsive grid.
- [ ] Each chart card shows title, current value, and delta badge.
- [ ] Delta badge colors are correct: green for improvement, red for regression.
- [ ] "Run Full Scan" button triggers POST and refreshes data.
- [ ] Insufficient data message shown when < 2 snapshots exist.
- [ ] "Last scanned" timestamp displays correctly.
- [ ] No console errors during navigation.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/client/pages/Trends.tsx` (create)
- **Related Files**:
  - `src/client/components/TrendChart.tsx` (STORY-008-04 — chart component)
  - `src/client/lib/api.ts` (existing — API client utility)
  - `src/client/App.tsx` (existing — route already defined as placeholder)
- **New Files Needed**:
  - `src/client/pages/Trends.tsx`

### 3.2 Technical Logic

**Step 1: Define types and metric configuration**

```typescript
// src/client/pages/Trends.tsx

import React, { useState, useEffect } from 'react';
import TrendChart from '../components/TrendChart';

type TrendPeriod = '7d' | '30d' | '90d';
type TrendDirection = 'up' | 'down' | 'flat';

interface MetricTrend {
  name: string;
  current: number | null;
  previous: number | null;
  delta: number | null;
  deltaPercent: number | null;
  direction: TrendDirection;
}

interface TrendData {
  repoId: string;
  period: TrendPeriod;
  insufficientData: boolean;
  metrics: MetricTrend[];
  history: Array<{
    timestamp: string;
    metrics: Record<string, number | null>;
  }>;
}

interface Repo {
  id: string;
  name: string;
  path: string;
  last_scan_at: string | null;
}

// Metric display configuration
// "lowerIsBetter" controls delta badge coloring:
//   true  -> down=green (improvement), up=red (regression)
//   false -> neutral coloring (informational metrics)
const METRIC_CONFIG: Array<{
  key: string;
  label: string;
  color: string;
  unit: string;
  lowerIsBetter: boolean;
}> = [
  { key: 'avgComplexity',         label: 'Avg Complexity',    color: '#3b82f6', unit: '',      lowerIsBetter: true },
  { key: 'maxComplexity',         label: 'Max Complexity',    color: '#8b5cf6', unit: '',      lowerIsBetter: true },
  { key: 'duplicationPercentage', label: 'Duplication %',     color: '#ef4444', unit: '%',     lowerIsBetter: true },
  { key: 'totalFiles',            label: 'Total Files',       color: '#06b6d4', unit: 'files', lowerIsBetter: false },
  { key: 'totalLines',            label: 'Total Lines',       color: '#10b981', unit: 'lines', lowerIsBetter: false },
  { key: 'avgFileSize',           label: 'Avg File Size',     color: '#f59e0b', unit: 'lines', lowerIsBetter: true },
  { key: 'errorPatternCount',     label: 'Error Patterns',    color: '#f97316', unit: '',      lowerIsBetter: true },
  { key: 'dependencyCount',       label: 'Dependencies',      color: '#64748b', unit: '',      lowerIsBetter: false },
];
```

**Step 2: Build the delta badge sub-component**

```tsx
function DeltaBadge({
  trend,
  lowerIsBetter,
}: {
  trend: MetricTrend;
  lowerIsBetter: boolean;
}) {
  if (trend.direction === 'flat' || trend.delta === null || trend.deltaPercent === null) {
    return (
      <span className="text-xs text-gray-400 px-1.5 py-0.5">
        --
      </span>
    );
  }

  // Determine if the change is good or bad
  const isImproving = lowerIsBetter
    ? trend.direction === 'down'   // Lower is better, so going down is good
    : trend.direction === 'up';    // Higher is okay (neutral metrics)

  // For "lowerIsBetter: false" metrics, use neutral blue instead of red/green
  let badgeClass: string;
  let arrow: string;

  if (lowerIsBetter) {
    badgeClass = isImproving
      ? 'bg-green-100 text-green-700'
      : 'bg-red-100 text-red-700';
    arrow = trend.direction === 'down' ? '\u2193' : '\u2191';
  } else {
    // Neutral coloring for informational metrics
    badgeClass = 'bg-gray-100 text-gray-600';
    arrow = trend.direction === 'down' ? '\u2193' : '\u2191';
  }

  const sign = trend.delta > 0 ? '+' : '';

  return (
    <span className={`text-xs px-1.5 py-0.5 rounded font-medium ${badgeClass}`}>
      {arrow} {sign}{trend.deltaPercent}%
    </span>
  );
}
```

**Step 3: Build the main Trends page component**

```tsx
export default function Trends() {
  const [repos, setRepos] = useState<Repo[]>([]);
  const [selectedRepoId, setSelectedRepoId] = useState<string>('');
  const [period, setPeriod] = useState<TrendPeriod>('30d');
  const [trendData, setTrendData] = useState<TrendData | null>(null);
  const [isScanning, setIsScanning] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [lastScanAt, setLastScanAt] = useState<string | null>(null);

  // Fetch repos
  useEffect(() => {
    fetch('/api/repos')
      .then(res => res.json())
      .then((data: Repo[]) => {
        setRepos(data);
        if (data.length > 0) {
          setSelectedRepoId(data[0].id);
          setLastScanAt(data[0].last_scan_at);
        }
      });
  }, []);

  // Fetch trend data when repo or period changes
  useEffect(() => {
    if (!selectedRepoId) return;
    setIsLoading(true);
    fetch(`/api/repos/${selectedRepoId}/trends?period=${period}`)
      .then(res => res.json())
      .then(setTrendData)
      .finally(() => setIsLoading(false));
  }, [selectedRepoId, period]);

  // Update lastScanAt when repo changes
  useEffect(() => {
    const repo = repos.find(r => r.id === selectedRepoId);
    setLastScanAt(repo?.last_scan_at ?? null);
  }, [selectedRepoId, repos]);

  // Handle full scan
  const handleScan = async () => {
    if (!selectedRepoId) return;
    setIsScanning(true);
    try {
      const res = await fetch(`/api/repos/${selectedRepoId}/scan`, { method: 'POST' });
      if (res.ok) {
        const data = await res.json();
        setLastScanAt(data.snapshot.timestamp);
        // Refresh trend data
        const trendRes = await fetch(
          `/api/repos/${selectedRepoId}/trends?period=${period}`
        );
        if (trendRes.ok) setTrendData(await trendRes.json());
      }
    } finally {
      setIsScanning(false);
    }
  };

  // Helper: extract chart data for a metric from history
  const getChartData = (metricKey: string) => {
    if (!trendData?.history) return [];
    return trendData.history.map(entry => ({
      timestamp: entry.timestamp,
      value: (entry.metrics as Record<string, number | null>)[metricKey] ?? null,
    }));
  };

  // Helper: find trend for a metric
  const getTrend = (metricKey: string): MetricTrend | null => {
    return trendData?.metrics.find(m => m.name === metricKey) ?? null;
  };

  return (/* JSX in Step 4 */);
}
```

**Step 4: Build the JSX layout**

```tsx
return (
  <div className="max-w-7xl">
    {/* Header */}
    <div className="flex items-center justify-between mb-6">
      <div className="flex items-center gap-4">
        <h1 className="text-2xl font-bold">Trends</h1>
        <select
          className="border rounded px-3 py-1.5 text-sm bg-white"
          value={selectedRepoId}
          onChange={e => setSelectedRepoId(e.target.value)}
        >
          {repos.map(r => (
            <option key={r.id} value={r.id}>{r.name}</option>
          ))}
        </select>
        {lastScanAt && (
          <span className="text-xs text-gray-400">
            Last scanned: {new Date(lastScanAt).toLocaleString()}
          </span>
        )}
      </div>
      <div className="flex items-center gap-3">
        {/* Period selector */}
        <div className="flex border rounded overflow-hidden">
          {(['7d', '30d', '90d'] as TrendPeriod[]).map(p => (
            <button
              key={p}
              className={`px-3 py-1.5 text-sm ${
                period === p
                  ? 'bg-blue-600 text-white'
                  : 'bg-white text-gray-600 hover:bg-gray-50'
              }`}
              onClick={() => setPeriod(p)}
            >
              {p === '7d' ? 'Week' : p === '30d' ? 'Month' : 'Quarter'}
            </button>
          ))}
        </div>
        {/* Scan button */}
        <button
          className="px-4 py-1.5 bg-blue-600 text-white text-sm rounded hover:bg-blue-700 disabled:opacity-50"
          onClick={handleScan}
          disabled={isScanning}
        >
          {isScanning ? 'Scanning...' : 'Run Full Scan'}
        </button>
      </div>
    </div>

    {/* Content */}
    {isLoading ? (
      <div className="text-center text-gray-400 mt-20">Loading trends...</div>
    ) : trendData?.insufficientData ? (
      <div className="text-center mt-20">
        <p className="text-gray-500 text-lg mb-4">
          Not enough data to show trends.
        </p>
        <p className="text-gray-400 mb-6">
          Run a Full Scan to capture your first snapshot.
        </p>
        <button
          className="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          onClick={handleScan}
          disabled={isScanning}
        >
          {isScanning ? 'Scanning...' : 'Run Full Scan'}
        </button>
      </div>
    ) : (
      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
        {METRIC_CONFIG.map(config => {
          const trend = getTrend(config.key);
          const chartData = getChartData(config.key);

          return (
            <div key={config.key} className="border rounded-lg bg-white p-4">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-medium text-gray-700">{config.label}</span>
                {trend && <DeltaBadge trend={trend} lowerIsBetter={config.lowerIsBetter} />}
              </div>
              <div className="text-2xl font-bold mb-3">
                {trend?.current !== null && trend?.current !== undefined
                  ? `${trend.current}${config.unit ? ` ${config.unit}` : ''}`
                  : '--'}
              </div>
              <TrendChart
                data={chartData}
                label=""
                color={config.color}
                unit={config.unit}
              />
            </div>
          );
        })}
      </div>
    )}
  </div>
);
```

**Step 5: Update App.tsx to use the real component**

```tsx
// In src/client/App.tsx, replace the placeholder:
import Trends from './pages/Trends';

// In the routes:
<Route path="/trends" element={<Trends />} />
```

### 3.3 API Contract
This story consumes the following endpoints (no new endpoints created):

| Method | Endpoint | Source Story |
|--------|----------|-------------|
| GET | `/api/repos` | EPIC-002 |
| GET | `/api/repos/:repoId/trends?period=30d` | STORY-008-03 |
| POST | `/api/repos/:repoId/scan` | STORY-008-03 |

---

## 4. Definition of Done (The Gate)
- [ ] `src/client/pages/Trends.tsx` exists and renders at the `/trends` route.
- [ ] Repo selector dropdown populates from API and triggers data refresh.
- [ ] Period selector (Week/Month/Quarter) updates charts when changed.
- [ ] 8 TrendChart components render in a responsive 2-3 column grid.
- [ ] Each chart card shows title, current value, and delta badge.
- [ ] Delta badges use correct coloring: green for improvement, red for regression on "lowerIsBetter" metrics; neutral for informational metrics.
- [ ] "Run Full Scan" button triggers POST and refreshes all charts.
- [ ] "Not enough data" message shown when `insufficientData` is true, with a scan button.
- [ ] "Last scanned" timestamp displays correctly.
- [ ] App.tsx updated to use real Trends component instead of placeholder.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
- [ ] No console errors when navigating the page.
