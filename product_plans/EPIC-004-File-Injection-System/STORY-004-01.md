---
id: STORY-004-01
parent_epic: EPIC-004
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-004-01: Injector Orchestrator

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a central injection orchestrator that coordinates platform-specific file generation and writes prepared content into target repositories,
**So that** all platform injectors share common logic for directory creation, file writing, error handling, and rollback.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `injectIntoRepo(repoId, deps)` — the main function that looks up the repo from the database (path, platform), loads all prepared content (skills, rules, commands, config), delegates to the appropriate platform-specific injector, updates `.gitignore`, and sets the `repos.injected_at` timestamp.
- **Requirement 2**: Implement `previewInjection(repoId, deps)` — returns a list of files that would be written (path, content, action: create | overwrite) without actually writing anything to disk.
- **Requirement 3**: Define the `InjectionPlan` type representing the full set of files to write, the repo path, and the target platform.
- **Requirement 4**: Define the `PlatformInjector` interface that all platform injectors must implement.
- **Requirement 5**: Implement shared logic for creating directories, writing files atomically, handling errors gracefully, and rolling back on failure (all-or-nothing injection).
- **Requirement 6**: Validate that the repo path exists and is writable before attempting injection.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Injector Orchestrator

  Scenario: Successful injection into a Claude Code repo
    Given a repo exists in the database with platform "claude-code" and a valid path
    And skills, rules, and commands content has been prepared
    When I call injectIntoRepo with the repo ID
    Then the platform-specific injector generates the correct file list
    And all files are written to the repo directory
    And .gitignore is updated with VibeLint entries
    And the repo's injected_at timestamp is updated in the database

  Scenario: Preview injection without writing
    Given a repo exists in the database with platform "cursor"
    When I call previewInjection with the repo ID
    Then an InjectionPlan is returned with file paths, content, and actions
    And no files are written to disk
    And the database is not modified

  Scenario: Rollback on write failure
    Given a repo exists with a valid path
    And one of the target file paths is not writable
    When I call injectIntoRepo with the repo ID
    Then all previously written files in this injection are removed
    And an error is returned describing the failure
    And the database injected_at is NOT updated

  Scenario: Repo path does not exist
    Given a repo's path in the database points to a non-existent directory
    When I call injectIntoRepo with the repo ID
    Then a validation error is returned with message "Repo path does not exist"
    And no files are written

  Scenario: Re-injection overwrites cleanly
    Given files were previously injected into a repo
    When I call injectIntoRepo again after modifying a skill
    Then existing files are overwritten with updated content
    And the action for those files is "overwrite" in the plan
```

### 2.2 Verification Steps
- [ ] `injectIntoRepo` writes all files returned by the platform injector to the correct paths.
- [ ] `previewInjection` returns the same file list as `injectIntoRepo` would write, but performs no I/O.
- [ ] If any file write fails, all files written during this injection run are rolled back (deleted).
- [ ] `repos.injected_at` is updated only on successful injection.
- [ ] A non-existent repo path returns a clear error without any side effects.
- [ ] Re-injection to the same repo overwrites files without creating duplicates.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/injector/index.ts`
- **Related Files**: `src/server/db/queries.ts` (repo lookup, timestamp update), `src/server/api/skills.ts` (load skills), `src/server/api/rules.ts` (load rules), `src/server/api/commands.ts` (load commands)
- **New Files Needed**:
  - `src/server/injector/index.ts`
  - `src/server/injector/types.ts` (shared types)

### 3.2 Technical Logic

**Step 1: Define shared types in `src/server/injector/types.ts`**

```typescript
/** Represents a single file to be written during injection */
export interface InjectionFile {
  /** Path relative to the repo root, e.g. ".vibelint/skills/general.md" */
  relativePath: string;
  /** Full file content to write */
  content: string;
  /** Whether this file will be created new or overwrite an existing file */
  action: 'create' | 'overwrite';
}

/** The complete injection plan for a repo */
export interface InjectionPlan {
  /** List of files to write */
  files: InjectionFile[];
  /** Absolute path to the repo root */
  repoPath: string;
  /** Target platform identifier */
  platform: string;
}

/** Content loaded from VibeLint's database/storage for injection */
export interface PreparedContent {
  /** Skill file contents: { filename: string, content: string }[] */
  skills: Array<{ filename: string; content: string }>;
  /** Platform rules content (e.g. CLAUDE.md body text) */
  rulesContent: string;
  /** Command files: { filename: string, content: string }[] */
  commands: Array<{ filename: string; content: string }>;
  /** Config YAML content */
  configContent: string;
  /** LESSONS.md content */
  lessonsContent: string;
}

/** Interface that every platform injector must implement */
export interface PlatformInjector {
  /** Platform identifier, e.g. "claude-code", "cursor" */
  platform: string;
  /** Generate the list of files for this platform given prepared content */
  generateFiles(content: PreparedContent): InjectionFile[];
}

/** Result of a successful injection */
export interface InjectionResult {
  success: boolean;
  filesWritten: string[];
  errors?: string[];
}

/** Dependencies injected into the orchestrator (for testability) */
export interface InjectorDeps {
  /** Database instance or query helper */
  db: import('better-sqlite3').Database;
  /** Function to load prepared content for a repo */
  loadContent: (repoId: string) => Promise<PreparedContent>;
}
```

**Step 2: Implement the orchestrator in `src/server/injector/index.ts`**

```typescript
import fs from 'node:fs';
import path from 'node:path';
import type {
  InjectionPlan,
  InjectionFile,
  InjectionResult,
  InjectorDeps,
  PlatformInjector,
  PreparedContent,
} from './types.js';
import { ClaudeCodeInjector } from './platforms/claude-code.js';
import { CursorInjector } from './platforms/cursor.js';
import { WindsurfInjector } from './platforms/windsurf.js';
import { GenericInjector } from './platforms/generic.js';
import { updateGitignore } from './gitignore.js';

/** Registry of platform injectors */
const platformInjectors: Record<string, PlatformInjector> = {
  'claude-code': new ClaudeCodeInjector(),
  'cursor': new CursorInjector(),
  'windsurf': new WindsurfInjector(),
  'generic': new GenericInjector(),
};

/**
 * Build an injection plan without writing any files.
 * Used for both preview and the actual injection path.
 */
async function buildInjectionPlan(
  repoId: string,
  deps: InjectorDeps
): Promise<InjectionPlan> {
  // 1. Look up repo from DB
  const repo = deps.db
    .prepare('SELECT id, path, platform FROM repos WHERE id = ?')
    .get(repoId) as { id: string; path: string; platform: string } | undefined;

  if (!repo) {
    throw new Error(`Repo not found: ${repoId}`);
  }

  // 2. Validate repo path exists
  if (!fs.existsSync(repo.path)) {
    throw new Error(`Repo path does not exist: ${repo.path}`);
  }

  // 3. Get the platform injector
  const injector = platformInjectors[repo.platform];
  if (!injector) {
    throw new Error(`Unsupported platform: ${repo.platform}`);
  }

  // 4. Load prepared content
  const content = await deps.loadContent(repoId);

  // 5. Generate files via platform injector
  const files = injector.generateFiles(content);

  // 6. Determine action (create vs overwrite) for each file
  const filesWithActions: InjectionFile[] = files.map((file) => {
    const absolutePath = path.join(repo.path, file.relativePath);
    const exists = fs.existsSync(absolutePath);
    return {
      ...file,
      action: exists ? 'overwrite' : 'create',
    };
  });

  return {
    files: filesWithActions,
    repoPath: repo.path,
    platform: repo.platform,
  };
}

/**
 * Preview what files would be written without actually writing them.
 */
export async function previewInjection(
  repoId: string,
  deps: InjectorDeps
): Promise<InjectionPlan> {
  return buildInjectionPlan(repoId, deps);
}

/**
 * Execute full injection: write all files, update .gitignore, update DB timestamp.
 * Rolls back all written files if any write fails.
 */
export async function injectIntoRepo(
  repoId: string,
  deps: InjectorDeps
): Promise<InjectionResult> {
  const plan = await buildInjectionPlan(repoId, deps);
  const writtenFiles: string[] = [];

  try {
    // Write each file
    for (const file of plan.files) {
      const absolutePath = path.join(plan.repoPath, file.relativePath);
      const dir = path.dirname(absolutePath);

      // Ensure directory exists
      fs.mkdirSync(dir, { recursive: true });

      // Write file content
      fs.writeFileSync(absolutePath, file.content, 'utf-8');
      writtenFiles.push(file.relativePath);
    }

    // Update .gitignore
    updateGitignore(plan.repoPath, plan.platform);

    // Update injected_at timestamp in database
    const now = new Date().toISOString();
    deps.db
      .prepare('UPDATE repos SET injected_at = ? WHERE id = ?')
      .run(now, repoId);

    return {
      success: true,
      filesWritten: writtenFiles,
    };
  } catch (error) {
    // Rollback: delete files that were written during this run
    for (const relativePath of writtenFiles) {
      const absolutePath = path.join(plan.repoPath, relativePath);
      try {
        fs.unlinkSync(absolutePath);
      } catch {
        // Best-effort cleanup; ignore errors during rollback
      }
    }

    const message =
      error instanceof Error ? error.message : 'Unknown injection error';
    return {
      success: false,
      filesWritten: [],
      errors: [message],
    };
  }
}
```

**Step 3: Validate repo path is writable**

Add a writability check inside `buildInjectionPlan` after confirming the path exists:

```typescript
try {
  fs.accessSync(repo.path, fs.constants.W_OK);
} catch {
  throw new Error(`Repo path is not writable: ${repo.path}`);
}
```

### 3.3 API Contract
N/A — this story is the internal orchestrator. The API routes are covered in STORY-004-06.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/injector/types.ts` exports `InjectionFile`, `InjectionPlan`, `PreparedContent`, `PlatformInjector`, `InjectionResult`, and `InjectorDeps` types.
- [ ] `src/server/injector/index.ts` exports `injectIntoRepo` and `previewInjection` functions.
- [ ] `injectIntoRepo` writes files, updates `.gitignore`, updates `repos.injected_at`, and returns `InjectionResult`.
- [ ] `previewInjection` returns an `InjectionPlan` without any disk writes or database changes.
- [ ] Rollback logic removes all files written during a failed injection attempt.
- [ ] Repo path validation returns clear error messages for missing or non-writable paths.
- [ ] Platform injector registry supports `claude-code`, `cursor`, `windsurf`, and `generic`.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
