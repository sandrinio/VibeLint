---
id: STORY-004-06
parent_epic: EPIC-004
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-004-06: Inject & Preview API

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** REST API endpoints for previewing and executing file injection into a repo,
**So that** the frontend can show a preview of files to be written and trigger the actual injection.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/server/api/inject.ts` as a Fastify route plugin.
- **Requirement 2**: Implement `POST /api/repos/:repoId/inject` — executes the full injection and returns `{ success: boolean, filesWritten: string[], errors?: string[] }`.
- **Requirement 3**: Implement `GET /api/repos/:repoId/inject/preview` — returns the injection plan without writing, including `{ files: Array<{ relativePath, content, action }>, repoPath, platform }`.
- **Requirement 4**: Validate that the repo exists in the database before processing.
- **Requirement 5**: Validate that the repo path exists on disk and is writable; return HTTP 400 with a descriptive error if not.
- **Requirement 6**: Return HTTP 404 if the repo ID is not found in the database.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Inject & Preview API

  Scenario: Preview injection for a valid repo
    Given a repo "repo-1" exists with platform "claude-code" and a valid path
    When I send GET /api/repos/repo-1/inject/preview
    Then the response status is 200
    And the body contains "files" as an array of injection file objects
    And each file object has "relativePath", "content", and "action" fields
    And "repoPath" and "platform" are included in the response

  Scenario: Execute injection for a valid repo
    Given a repo "repo-1" exists with platform "cursor" and a valid path
    When I send POST /api/repos/repo-1/inject
    Then the response status is 200
    And the body contains "success" as true
    And "filesWritten" is an array of relative paths
    And the repo's injected_at is updated in the database

  Scenario: Repo not found
    Given no repo exists with ID "nonexistent"
    When I send GET /api/repos/nonexistent/inject/preview
    Then the response status is 404
    And the body contains an error message "Repo not found"

  Scenario: Repo path does not exist
    Given a repo "repo-2" exists but its path points to a non-existent directory
    When I send POST /api/repos/repo-2/inject
    Then the response status is 400
    And the body contains an error message about the path not existing

  Scenario: Repo path is not writable
    Given a repo "repo-3" exists but its path is read-only
    When I send POST /api/repos/repo-3/inject
    Then the response status is 400
    And the body contains an error message about the path not being writable

  Scenario: Injection failure returns errors
    Given a repo "repo-4" exists with a valid path but a file write fails
    When I send POST /api/repos/repo-4/inject
    Then the response status is 200
    And the body contains "success" as false
    And "errors" is an array with at least one error message
```

### 2.2 Verification Steps
- [ ] `GET /api/repos/:repoId/inject/preview` returns 200 with a full injection plan.
- [ ] `POST /api/repos/:repoId/inject` returns 200 with injection result.
- [ ] Invalid repo ID returns 404.
- [ ] Invalid repo path returns 400 with descriptive error.
- [ ] Successful injection updates `repos.injected_at` in the database.
- [ ] Failed injection returns `success: false` with error descriptions.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/api/inject.ts`
- **Related Files**: `src/server/injector/index.ts` (injectIntoRepo, previewInjection), `src/server/index.ts` (register plugin), `src/server/db/queries.ts` (repo lookup)
- **New Files Needed**:
  - `src/server/api/inject.ts`

### 3.2 Technical Logic

**Step 1: Create the Fastify route plugin**

```typescript
import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { injectIntoRepo, previewInjection } from '../injector/index.js';
import type { InjectorDeps } from '../injector/types.js';

/** Params schema for routes with :repoId */
interface RepoParams {
  repoId: string;
}

/**
 * Fastify plugin that registers inject-related routes.
 * Expects the Fastify instance to have `db` decorated on it.
 */
export default async function injectRoutes(
  fastify: FastifyInstance
): Promise<void> {
  /**
   * GET /api/repos/:repoId/inject/preview
   *
   * Returns the injection plan (files, paths, actions) without writing.
   */
  fastify.get<{ Params: RepoParams }>(
    '/api/repos/:repoId/inject/preview',
    async (request, reply) => {
      const { repoId } = request.params;
      const deps = buildDeps(fastify);

      try {
        const plan = await previewInjection(repoId, deps);
        return reply.status(200).send(plan);
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Unknown error';

        if (message.includes('Repo not found')) {
          return reply.status(404).send({ error: message });
        }
        if (
          message.includes('does not exist') ||
          message.includes('not writable')
        ) {
          return reply.status(400).send({ error: message });
        }

        return reply.status(500).send({ error: message });
      }
    }
  );

  /**
   * POST /api/repos/:repoId/inject
   *
   * Executes full injection: writes files, updates gitignore, updates DB.
   */
  fastify.post<{ Params: RepoParams }>(
    '/api/repos/:repoId/inject',
    async (request, reply) => {
      const { repoId } = request.params;
      const deps = buildDeps(fastify);

      try {
        const result = await injectIntoRepo(repoId, deps);
        return reply.status(200).send(result);
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Unknown error';

        if (message.includes('Repo not found')) {
          return reply.status(404).send({ error: message });
        }
        if (
          message.includes('does not exist') ||
          message.includes('not writable')
        ) {
          return reply.status(400).send({ error: message });
        }

        return reply.status(500).send({ error: message });
      }
    }
  );
}

/**
 * Build the InjectorDeps object from the Fastify instance.
 * The db is expected to be decorated on the Fastify instance.
 */
function buildDeps(fastify: FastifyInstance): InjectorDeps {
  // Access the decorated db instance
  const db = (fastify as any).db;

  return {
    db,
    loadContent: async (repoId: string) => {
      // Load prepared content from the database/storage
      // This queries skills, rules, commands, config for the given repo
      return loadPreparedContent(db, repoId);
    },
  };
}

/**
 * Load all prepared content for a repo from the database.
 * Queries skills, rules, commands, config, and lessons tables/storage.
 */
async function loadPreparedContent(
  db: import('better-sqlite3').Database,
  repoId: string
): Promise<import('../injector/types.js').PreparedContent> {
  // Query the repo to get its platform
  const repo = db
    .prepare('SELECT platform FROM repos WHERE id = ?')
    .get(repoId) as { platform: string } | undefined;

  if (!repo) {
    throw new Error(`Repo not found: ${repoId}`);
  }

  // Load skills from the skills storage (DB or template files)
  // This will be implemented by EPIC-003's storage layer
  // For now, define the expected query interface:
  const skills = loadSkillsForRepo(db, repoId);
  const rulesContent = loadRulesForRepo(db, repoId);
  const commands = loadCommandsForRepo(db, repoId, repo.platform);
  const configContent = loadConfigForRepo(db, repoId);
  const lessonsContent = loadLessonsForRepo(db, repoId);

  return {
    skills,
    rulesContent,
    commands,
    configContent,
    lessonsContent,
  };
}

// --- Content loading helpers ---
// These functions query VibeLint's internal storage.
// They depend on EPIC-003 tables being populated.

function loadSkillsForRepo(
  db: import('better-sqlite3').Database,
  repoId: string
): Array<{ filename: string; content: string }> {
  // Query skills associated with this repo
  // Falls back to default templates if no customizations exist
  const rows = db
    .prepare(
      'SELECT filename, content FROM skills WHERE repo_id = ? ORDER BY filename'
    )
    .all(repoId) as Array<{ filename: string; content: string }>;

  return rows;
}

function loadRulesForRepo(
  db: import('better-sqlite3').Database,
  repoId: string
): string {
  const row = db
    .prepare('SELECT content FROM rules WHERE repo_id = ?')
    .get(repoId) as { content: string } | undefined;

  return row?.content ?? '# Project Rules\n\n<!-- Add your project rules here -->\n';
}

function loadCommandsForRepo(
  db: import('better-sqlite3').Database,
  repoId: string,
  platform: string
): Array<{ filename: string; content: string }> {
  const rows = db
    .prepare(
      'SELECT filename, content FROM commands WHERE repo_id = ? AND (platform = ? OR platform = "all") ORDER BY filename'
    )
    .all(repoId, platform) as Array<{ filename: string; content: string }>;

  return rows;
}

function loadConfigForRepo(
  db: import('better-sqlite3').Database,
  repoId: string
): string {
  const row = db
    .prepare(
      "SELECT value FROM config WHERE key = 'repo_config_' || ?"
    )
    .get(repoId) as { value: string } | undefined;

  return row?.value ?? '# VibeLint Configuration\nthresholds:\n  complexity: 15\n  duplication: 5\n  file_size: 500\n';
}

function loadLessonsForRepo(
  db: import('better-sqlite3').Database,
  repoId: string
): string {
  const row = db
    .prepare('SELECT content FROM lessons WHERE repo_id = ?')
    .get(repoId) as { content: string } | undefined;

  return row?.content ?? '# Lessons Learned\n\n<!-- Add project-specific lessons here -->\n';
}
```

**Step 2: Register the plugin in the Fastify server**

In `src/server/index.ts`, register the inject routes plugin:

```typescript
import injectRoutes from './api/inject.js';

// Inside server setup:
await fastify.register(injectRoutes);
```

**Step 3: Response type definitions for the frontend**

```typescript
/** Response from GET /api/repos/:repoId/inject/preview */
export interface PreviewResponse {
  files: Array<{
    relativePath: string;
    content: string;
    action: 'create' | 'overwrite';
  }>;
  repoPath: string;
  platform: string;
}

/** Response from POST /api/repos/:repoId/inject */
export interface InjectResponse {
  success: boolean;
  filesWritten: string[];
  errors?: string[];
}
```

### 3.3 API Contract

| Method | Path | Request Body | Response (200) | Error Responses |
|--------|------|--------------|----------------|-----------------|
| `GET` | `/api/repos/:repoId/inject/preview` | None | `{ files: InjectionFile[], repoPath: string, platform: string }` | 404: `{ error: "Repo not found" }`, 400: `{ error: "path issue" }` |
| `POST` | `/api/repos/:repoId/inject` | None | `{ success: boolean, filesWritten: string[], errors?: string[] }` | 404: `{ error: "Repo not found" }`, 400: `{ error: "path issue" }` |

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/api/inject.ts` exports a Fastify plugin with two routes.
- [ ] `GET /api/repos/:repoId/inject/preview` returns 200 with injection plan.
- [ ] `POST /api/repos/:repoId/inject` returns 200 with injection result.
- [ ] 404 returned when repo ID does not exist in the database.
- [ ] 400 returned when repo path does not exist or is not writable.
- [ ] Plugin is registered in `src/server/index.ts`.
- [ ] Content loading functions query VibeLint's internal storage.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
