---
id: STORY-004-05
parent_epic: EPIC-004
status: Draft
actor: Backend Developer
complexity: Low (1 file)
---
# STORY-004-05: Gitignore Updater

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a gitignore updater that appends VibeLint-specific entries to a repo's `.gitignore` file,
**So that** injected files remain local-only and are not committed to the repository.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `updateGitignore(repoPath, platform)` that reads the existing `.gitignore` (or creates one if it does not exist), and appends VibeLint entries if they are not already present.
- **Requirement 2**: Add a `# VibeLint` section header comment before the VibeLint entries.
- **Requirement 3**: Always add `.vibelint/` to the gitignore. Add platform-specific entries: `.claude/` for Claude Code, `.cursor/` for Cursor, `.windsurf/` for Windsurf.
- **Requirement 4**: Parse the existing gitignore content to detect duplicate entries and avoid adding them again (idempotent operation).
- **Requirement 5**: Handle three cases: (a) no `.gitignore` exists, (b) `.gitignore` exists but has no VibeLint entries, (c) `.gitignore` already has VibeLint entries (no-op).
- **Requirement 6**: Preserve all existing gitignore content unchanged; only append to the end of the file.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Gitignore Updater

  Scenario: No .gitignore exists
    Given a repo directory with no .gitignore file
    When I call updateGitignore with platform "claude-code"
    Then a .gitignore file is created
    And it contains "# VibeLint"
    And it contains ".vibelint/"
    And it contains ".claude/"

  Scenario: .gitignore exists without VibeLint entries
    Given a repo with an existing .gitignore containing "node_modules/" and "dist/"
    When I call updateGitignore with platform "cursor"
    Then the .gitignore still contains "node_modules/" and "dist/"
    And it now contains "# VibeLint"
    And it now contains ".vibelint/"
    And it now contains ".cursor/"

  Scenario: .gitignore already has VibeLint entries (idempotent)
    Given a repo with a .gitignore that already contains "# VibeLint", ".vibelint/", ".claude/"
    When I call updateGitignore with platform "claude-code"
    Then no duplicate entries are added
    And the file content has not changed

  Scenario: Platform-specific entries for Windsurf
    Given a repo directory
    When I call updateGitignore with platform "windsurf"
    Then the .gitignore contains ".vibelint/"
    And the .gitignore contains ".windsurf/"
    And the .gitignore does NOT contain ".claude/" or ".cursor/"

  Scenario: Generic platform only adds .vibelint/
    Given a repo directory
    When I call updateGitignore with platform "generic"
    Then the .gitignore contains ".vibelint/"
    And the .gitignore does NOT contain ".claude/", ".cursor/", or ".windsurf/"

  Scenario: Existing content is preserved
    Given a repo with a .gitignore containing custom entries and comments
    When I call updateGitignore with any platform
    Then all original content is preserved verbatim
    And VibeLint entries are appended after a blank line at the end
```

### 2.2 Verification Steps
- [ ] When no `.gitignore` exists, one is created with VibeLint entries.
- [ ] Existing `.gitignore` content is never modified or removed.
- [ ] VibeLint entries include the `# VibeLint` section header.
- [ ] `.vibelint/` is always included regardless of platform.
- [ ] Platform-specific directories are included only for the correct platform.
- [ ] Calling `updateGitignore` twice produces the same file content (idempotent).

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/injector/gitignore.ts`
- **Related Files**: `src/server/injector/index.ts` (calls `updateGitignore`)
- **New Files Needed**:
  - `src/server/injector/gitignore.ts`

### 3.2 Technical Logic

**Step 1: Define platform-specific gitignore entries**

```typescript
import fs from 'node:fs';
import path from 'node:path';

/** Entries to add to .gitignore per platform */
const PLATFORM_GITIGNORE_ENTRIES: Record<string, string[]> = {
  'claude-code': ['.vibelint/', '.claude/'],
  'cursor': ['.vibelint/', '.cursor/'],
  'windsurf': ['.vibelint/', '.windsurf/'],
  'generic': ['.vibelint/'],
};

const VIBELINT_SECTION_HEADER = '# VibeLint';
```

**Step 2: Implement `updateGitignore`**

```typescript
/**
 * Update .gitignore in the repo to include VibeLint entries.
 * Idempotent: safe to call multiple times without duplicating entries.
 *
 * @param repoPath - Absolute path to the repo root
 * @param platform - Platform identifier (claude-code, cursor, windsurf, generic)
 */
export function updateGitignore(repoPath: string, platform: string): void {
  const gitignorePath = path.join(repoPath, '.gitignore');
  const entries = PLATFORM_GITIGNORE_ENTRIES[platform] ?? ['.vibelint/'];

  // Read existing content or start empty
  let existingContent = '';
  if (fs.existsSync(gitignorePath)) {
    existingContent = fs.readFileSync(gitignorePath, 'utf-8');
  }

  // Parse existing entries (non-empty, non-comment lines, trimmed)
  const existingLines = new Set(
    existingContent
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line.length > 0)
  );

  // Determine which entries are missing
  const missingEntries = entries.filter(
    (entry) => !existingLines.has(entry)
  );

  // If all entries already present, nothing to do
  if (missingEntries.length === 0) {
    return;
  }

  // Build the new section to append
  const newSection: string[] = [];

  // Add a blank line separator if existing content doesn't end with one
  if (
    existingContent.length > 0 &&
    !existingContent.endsWith('\n\n')
  ) {
    newSection.push('');
  }

  // Add header if not already present
  if (!existingLines.has(VIBELINT_SECTION_HEADER)) {
    newSection.push(VIBELINT_SECTION_HEADER);
  }

  // Add missing entries
  for (const entry of missingEntries) {
    newSection.push(entry);
  }

  // Ensure trailing newline
  newSection.push('');

  // Append to file
  const contentToAppend = newSection.join('\n');

  if (existingContent.length === 0) {
    // Create new file
    fs.writeFileSync(gitignorePath, contentToAppend, 'utf-8');
  } else {
    // Append to existing file
    fs.appendFileSync(gitignorePath, contentToAppend, 'utf-8');
  }
}
```

**Step 3: Integration with the orchestrator**

In `src/server/injector/index.ts`, call `updateGitignore` after writing all files:

```typescript
import { updateGitignore } from './gitignore.js';

// Inside injectIntoRepo, after writing all files:
updateGitignore(plan.repoPath, plan.platform);
```

**Step 4: Handle edge cases**

- `.gitignore` with Windows line endings (`\r\n`): The line splitting handles this because `trim()` removes `\r`.
- `.gitignore` with trailing whitespace on entries: `trim()` normalizes comparisons.
- Empty `.gitignore` file (0 bytes): Treated the same as non-existent.

### 3.3 API Contract
N/A â€” this is an internal utility called by the injection orchestrator.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/injector/gitignore.ts` exports `updateGitignore(repoPath, platform)`.
- [ ] Creates `.gitignore` if it does not exist.
- [ ] Appends `# VibeLint` section header and platform-specific entries.
- [ ] Always includes `.vibelint/` regardless of platform.
- [ ] Includes `.claude/` for claude-code, `.cursor/` for cursor, `.windsurf/` for windsurf.
- [ ] Does not add duplicate entries (idempotent).
- [ ] Preserves all existing `.gitignore` content unchanged.
- [ ] TypeScript compiles with no errors (`npx tsc --noEmit`).
