---
id: STORY-002-03
parent_epic: EPIC-002
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-002-03: Repo CRUD API

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** REST API endpoints for adding, listing, re-scanning, and removing repositories,
**So that** the frontend can manage connected repositories through a clean HTTP interface.

### 1.2 Detailed Requirements
- **Requirement 1**: Create `src/server/api/repos.ts` as a Fastify route plugin (using `fastify.register`).
- **Requirement 2**: `GET /api/repos` — list all repos from the database with their full scan metadata.
- **Requirement 3**: `POST /api/repos` — add a new repo. Accept `{ path: string }` in the request body. Validate the path, run `scanRepo()`, insert into the database, and return the full repo record with scan data.
- **Requirement 4**: `DELETE /api/repos/:id` — remove a repo from the database by ID.
- **Requirement 5**: `POST /api/repos/:id/scan` — re-scan an existing repo, updating languages, branches, and existing files in the database.
- **Requirement 6**: Use `nanoid` for generating unique repo IDs.
- **Requirement 7**: Each response includes full scan data (languages parsed from JSON, branches, existing files from a fresh or cached scan).
- **Requirement 8**: Register this plugin in the main Fastify server (`src/server/index.ts`).
- **Requirement 9**: **Path Traversal Protection** — Before processing any repo path, resolve it with `path.resolve()`, verify it is an absolute path to an existing directory, and confirm it contains a `.git` directory. Reject paths like `../../etc/passwd` or symlinks escaping the expected boundary.
- **Requirement 10**: **Command Injection Prevention** — All git commands in `scanRepo()` and related functions MUST use `child_process.execFile` (array arguments) or `child_process.spawn` with `cwd` option. NEVER use `child_process.exec` with string interpolation of user-provided paths.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Repo CRUD API

  Scenario: List repos when none exist
    Given the database has no repos
    When I send GET /api/repos
    Then the response status is 200
    And the response body is an empty array []

  Scenario: Add a valid repository
    Given a valid git repository exists at "/path/to/repo"
    When I send POST /api/repos with body { "path": "/path/to/repo" }
    Then the response status is 201
    And the response body includes id, name, path, languages, and scan data
    And the repo is persisted in the database

  Scenario: Add a duplicate repository
    Given a repo at "/path/to/repo" is already in the database
    When I send POST /api/repos with body { "path": "/path/to/repo" }
    Then the response status is 409
    And the response body includes an error message about duplicate path

  Scenario: Add a non-existent path
    Given the path "/nonexistent/path" does not exist
    When I send POST /api/repos with body { "path": "/nonexistent/path" }
    Then the response status is 400
    And the response body includes an error message

  Scenario: Reject path traversal attempt
    Given the path "../../etc/passwd" is provided
    When I send POST /api/repos with body { "path": "../../etc/passwd" }
    Then the response status is 400
    And the response body includes "Invalid repository path"

  Scenario: Reject path without .git directory
    Given the path "/tmp/not-a-git-repo" exists but has no .git directory
    When I send POST /api/repos with body { "path": "/tmp/not-a-git-repo" }
    Then the response status is 400
    And the response body includes "not a git repository"

  Scenario: Delete a repository
    Given a repo with id "abc123" exists in the database
    When I send DELETE /api/repos/abc123
    Then the response status is 200
    And the repo is removed from the database

  Scenario: Delete a non-existent repository
    Given no repo with id "xyz999" exists
    When I send DELETE /api/repos/xyz999
    Then the response status is 404

  Scenario: Re-scan a repository
    Given a repo with id "abc123" exists in the database
    When I send POST /api/repos/abc123/scan
    Then the response status is 200
    And the response body includes updated scan data
    And last_scan_at is updated in the database
```

### 2.2 Verification Steps
- [ ] `GET /api/repos` returns an empty array initially, then includes added repos.
- [ ] `POST /api/repos` with a valid git repo path returns 201 with complete data.
- [ ] `POST /api/repos` with an invalid path returns 400.
- [ ] `POST /api/repos` with a duplicate path returns 409.
- [ ] `DELETE /api/repos/:id` removes the repo and returns 200.
- [ ] `DELETE /api/repos/:id` with a non-existent ID returns 404.
- [ ] `POST /api/repos/:id/scan` updates scan data and returns 200.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/api/repos.ts`
- **Related Files**:
  - `src/server/index.ts` (register the plugin)
  - `src/server/git/scanner.ts` (STORY-002-01, provides `scanRepo`)
  - `src/server/db/queries.ts` (STORY-001-04, provides repo CRUD helpers)
- **New Files Needed**: Yes — `src/server/api/repos.ts`

### 3.2 Technical Logic

**Step 1: Install nanoid**

```bash
npm install nanoid
```

**Step 2: Create `src/server/api/repos.ts`**

```typescript
import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { nanoid } from 'nanoid';
import path from 'node:path';
import fs from 'node:fs';
import { scanRepo, type RepoScanResult } from '../git/scanner.js';
import {
  createRepo,
  getRepo,
  listRepos,
  deleteRepo,
  updateRepo,
  type CreateRepoInput,
} from '../db/queries.js';
import type { RepoRow } from '../db/schema.js';

// --- Types for API responses ---

interface RepoResponse {
  id: string;
  path: string;
  name: string;
  languages: string[];
  platform: string | null;
  injected_at: string | null;
  created_at: string;
  last_scan_at: string | null;
  scan?: RepoScanResult;
}

function formatRepoResponse(row: RepoRow, scan?: RepoScanResult): RepoResponse {
  return {
    id: row.id,
    path: row.path,
    name: row.name,
    languages: JSON.parse(row.languages),
    platform: row.platform,
    injected_at: row.injected_at,
    created_at: row.created_at,
    last_scan_at: row.last_scan_at,
    scan,
  };
}

// --- Route Plugin ---

export default async function reposRoutes(fastify: FastifyInstance): Promise<void> {

  // GET /api/repos — list all repos
  fastify.get('/api/repos', async (_request: FastifyRequest, _reply: FastifyReply) => {
    const rows = listRepos();
    return rows.map((row) => formatRepoResponse(row));
  });

  // POST /api/repos — add a new repo
  fastify.post('/api/repos', async (request: FastifyRequest, reply: FastifyReply) => {
    const { path: rawPath } = request.body as { path: string };

    if (!rawPath || typeof rawPath !== 'string') {
      return reply.status(400).send({ error: 'Missing or invalid "path" in request body.' });
    }

    // --- Path Traversal Protection ---
    const repoPath = path.resolve(rawPath);

    // Verify it's a real directory
    try {
      const stat = fs.statSync(repoPath);
      if (!stat.isDirectory()) {
        return reply.status(400).send({ error: 'Invalid repository path: not a directory.' });
      }
    } catch {
      return reply.status(400).send({ error: 'Invalid repository path: directory does not exist.' });
    }

    // Verify it contains a .git directory (or .git file for submodules)
    const gitPath = path.join(repoPath, '.git');
    if (!fs.existsSync(gitPath)) {
      return reply.status(400).send({ error: 'Invalid repository path: not a git repository (no .git found).' });
    }

    // Check for duplicate (using resolved path for consistency)
    const existing = listRepos().find((r) => r.path === repoPath);
    if (existing) {
      return reply.status(409).send({
        error: `Repository at "${repoPath}" is already connected.`,
        existingId: existing.id,
      });
    }

    // Scan the repo
    let scan: RepoScanResult;
    try {
      scan = await scanRepo(repoPath);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to scan repository.';
      return reply.status(400).send({ error: message });
    }

    // Insert into DB
    const id = nanoid(12);
    const input: CreateRepoInput = {
      id,
      path: scan.path,
      name: scan.name,
      languages: scan.languages,
    };

    const row = createRepo(input);
    return reply.status(201).send(formatRepoResponse(row, scan));
  });

  // DELETE /api/repos/:id — remove a repo
  fastify.delete('/api/repos/:id', async (request: FastifyRequest, reply: FastifyReply) => {
    const { id } = request.params as { id: string };

    const existing = getRepo(id);
    if (!existing) {
      return reply.status(404).send({ error: `Repo not found: ${id}` });
    }

    deleteRepo(id);
    return { success: true, id };
  });

  // POST /api/repos/:id/scan — re-scan a repo
  fastify.post('/api/repos/:id/scan', async (request: FastifyRequest, reply: FastifyReply) => {
    const { id } = request.params as { id: string };

    const existing = getRepo(id);
    if (!existing) {
      return reply.status(404).send({ error: `Repo not found: ${id}` });
    }

    // Re-scan
    let scan: RepoScanResult;
    try {
      scan = await scanRepo(existing.path);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to re-scan repository.';
      return reply.status(500).send({ error: message });
    }

    // Update DB
    const updated = updateRepo(id, {
      languages: JSON.stringify(scan.languages),
      last_scan_at: new Date().toISOString(),
    });

    if (!updated) {
      return reply.status(500).send({ error: 'Failed to update repo after scan.' });
    }

    return formatRepoResponse(updated, scan);
  });
}
```

**Step 3: Register the plugin in `src/server/index.ts`**

Add to the `createServer()` function, after CORS and before static files:

```typescript
import reposRoutes from './api/repos.js';

// Inside createServer():
await server.register(reposRoutes);
```

**Step 4: Verify with curl**

```bash
# List repos (empty)
curl http://localhost:3847/api/repos
# []

# Add a repo
curl -X POST http://localhost:3847/api/repos \
  -H "Content-Type: application/json" \
  -d '{"path": "/path/to/your/repo"}'
# { "id": "abc123...", "name": "your-repo", ... }

# List repos (now has one)
curl http://localhost:3847/api/repos
# [{ "id": "abc123...", ... }]

# Re-scan
curl -X POST http://localhost:3847/api/repos/abc123.../scan

# Delete
curl -X DELETE http://localhost:3847/api/repos/abc123...
```

### 3.3 API Contract

| Method | Path                     | Request Body            | Response (Success)                     | Response (Error)                      |
|--------|--------------------------|-------------------------|----------------------------------------|---------------------------------------|
| GET    | `/api/repos`             | N/A                     | `200` — `RepoResponse[]`              | N/A                                   |
| POST   | `/api/repos`             | `{ "path": string }`   | `201` — `RepoResponse` with scan data | `400` — invalid path; `409` — duplicate |
| DELETE | `/api/repos/:id`         | N/A                     | `200` — `{ success: true, id }`       | `404` — not found                     |
| POST   | `/api/repos/:id/scan`    | N/A                     | `200` — `RepoResponse` with scan data | `404` — not found; `500` — scan failed |

**RepoResponse shape:**
```typescript
{
  id: string;
  path: string;
  name: string;
  languages: string[];
  platform: string | null;
  injected_at: string | null;
  created_at: string;
  last_scan_at: string | null;
  scan?: {
    path: string;
    name: string;
    languages: string[];
    branches: string[];
    currentBranch: string;
    existingFiles: Record<string, boolean>;
  };
}
```

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/api/repos.ts` exists and exports a Fastify plugin with all 4 routes.
- [ ] Plugin is registered in `src/server/index.ts`.
- [ ] `GET /api/repos` returns an array of repos.
- [ ] `POST /api/repos` validates the path, scans the repo, inserts into DB, and returns 201.
- [ ] `POST /api/repos` returns 400 for invalid paths and 409 for duplicates.
- [ ] **Path traversal is prevented**: paths are resolved with `path.resolve()`, verified as real directories containing `.git`.
- [ ] **No command injection**: all git commands use `execFile`/`spawn` with array args (never `exec` with string interpolation).
- [ ] `DELETE /api/repos/:id` removes the repo and returns 200 (or 404 if not found).
- [ ] `POST /api/repos/:id/scan` re-scans and updates the DB.
- [ ] `nanoid` is used for ID generation.
- [ ] All responses include properly parsed `languages` (array, not JSON string).
- [ ] TypeScript compiles without errors.
