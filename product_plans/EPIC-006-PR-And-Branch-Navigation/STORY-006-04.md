---
id: STORY-006-04
parent_epic: EPIC-006
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-006-04: Per-Branch Analysis API

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** API endpoints that trigger the analyzer engine on a specific branch's changes and persist the results,
**So that** the PR Navigator can show analysis results for any branch and users can compare quality between branches.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `POST /api/repos/:repoId/branches/:branch/analyze` that runs the analyzer engine (from EPIC-005) scoped to the files changed in the specified branch vs a base branch.
- **Requirement 2**: Store analysis results in the `analyses` table with `branch` and `base_branch` fields populated, along with `diff_stats` (JSON of BranchDiffSummary) and `analysis_data` (JSON of the analysis report).
- **Requirement 3**: Implement `GET /api/repos/:repoId/branches/:branch/analysis` that retrieves the most recent analysis for the given branch, or returns 404 if none exists.
- **Requirement 4**: Accept a `base` query parameter on both endpoints (default: auto-detect main/master).
- **Requirement 5**: The POST endpoint should return the analysis results immediately (synchronous execution) since the analyzer scopes to changed files only (should be fast for typical branch diffs).
- **Requirement 6**: If analysis is already running for this branch (future concern), return 409 Conflict.
- **Requirement 7**: Store a `created_at` timestamp on each analysis record so the UI can display when the analysis was last run.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Per-Branch Analysis API

  Scenario: Trigger analysis on a branch
    Given repo "repo-1" exists with path "/projects/myapp"
    And branch "feature/auth" has 5 files changed vs "main"
    When I POST /api/repos/repo-1/branches/feature%2Fauth/analyze
    Then the response status is 200
    And the body contains analysis results with data for the changed files
    And a record is inserted into the analyses table with branch "feature/auth"

  Scenario: Retrieve existing analysis
    Given an analysis exists for repo "repo-1" branch "feature/auth"
    When I GET /api/repos/repo-1/branches/feature%2Fauth/analysis
    Then the response status is 200
    And the body contains the stored analysis data and diff stats
    And the body contains a created_at timestamp

  Scenario: No analysis exists yet
    Given no analysis has been run for repo "repo-1" branch "feature/new"
    When I GET /api/repos/repo-1/branches/feature%2Fnew/analysis
    Then the response status is 404
    And the body contains { error: "No analysis found for branch feature/new", code: "ANALYSIS_NOT_FOUND" }

  Scenario: Custom base branch
    Given repo "repo-1" has branches "develop" and "feature/auth"
    When I POST /api/repos/repo-1/branches/feature%2Fauth/analyze?base=develop
    Then the analysis is run against "develop" instead of "main"
    And the stored record has base_branch "develop"

  Scenario: Repo not found
    Given no repo with id "nonexistent" exists
    When I POST /api/repos/nonexistent/branches/feature%2Fauth/analyze
    Then the response status is 404
    And the body contains { error: "Repository not found", code: "REPO_NOT_FOUND" }
```

### 2.2 Verification Steps
- [ ] `POST /api/repos/:repoId/branches/:branch/analyze` returns 200 with analysis data.
- [ ] Analysis result is persisted in the `analyses` table with correct branch, base_branch, diff_stats, analysis_data.
- [ ] `GET /api/repos/:repoId/branches/:branch/analysis` returns the most recent analysis.
- [ ] 404 returned when no analysis exists for a branch.
- [ ] `base` query parameter overrides auto-detected default branch.
- [ ] 404 returned for unknown repoId.
- [ ] `created_at` timestamp is present on stored and returned records.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/api/branches.ts` (extend from STORY-006-03)
- **Related Files**:
  - `src/server/analyzer/engine.ts` (EPIC-005 — `runAnalysis` function)
  - `src/server/git/diff.ts` (STORY-006-01 — `getBranchDiff`)
  - `src/server/db/queries.ts` (existing — repo lookup + new analysis queries)
  - `src/server/db/schema.ts` (existing — `analyses` table already defined in PRD)
- **New Files Needed**: None (extend existing `branches.ts` and `queries.ts`)

### 3.2 Technical Logic

**Step 1: Add analysis query functions to db/queries.ts**

```typescript
// Add to src/server/db/queries.ts

export interface AnalysisRecord {
  id: number;
  repo_id: string;
  branch: string;
  base_branch: string;
  diff_stats: string;      // JSON string
  analysis_data: string;   // JSON string
  created_at: string;      // ISO 8601
}

export function insertAnalysis(
  repoId: string,
  branch: string,
  baseBranch: string,
  diffStats: object,
  analysisData: object
): AnalysisRecord {
  const stmt = db.prepare(`
    INSERT INTO analyses (repo_id, branch, base_branch, diff_stats, analysis_data, created_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `);
  const now = new Date().toISOString();
  const result = stmt.run(
    repoId,
    branch,
    baseBranch,
    JSON.stringify(diffStats),
    JSON.stringify(analysisData),
    now
  );
  return getAnalysisById(result.lastInsertRowid as number)!;
}

export function getLatestAnalysis(
  repoId: string,
  branch: string
): AnalysisRecord | undefined {
  const stmt = db.prepare(`
    SELECT * FROM analyses
    WHERE repo_id = ? AND branch = ?
    ORDER BY created_at DESC
    LIMIT 1
  `);
  return stmt.get(repoId, branch) as AnalysisRecord | undefined;
}

function getAnalysisById(id: number): AnalysisRecord | undefined {
  const stmt = db.prepare('SELECT * FROM analyses WHERE id = ?');
  return stmt.get(id) as AnalysisRecord | undefined;
}
```

**Step 2: Add analysis routes to branches.ts**

```typescript
// Add to src/server/api/branches.ts
import { runAnalysis } from '../analyzer/engine.js';
import { insertAnalysis, getLatestAnalysis } from '../db/queries.js';

// Inside the branchRoutes plugin function:

// POST /api/repos/:repoId/branches/:branch/analyze
fastify.post<{ Params: BranchParams; Querystring: DiffQuery }>(
  '/api/repos/:repoId/branches/:branch/analyze',
  async (request, reply) => {
    const { repoId, branch } = request.params;
    const { base } = request.query;

    const repo = getRepoById(repoId);
    if (!repo) {
      return reply.status(404).send({
        error: 'Repository not found',
        code: 'REPO_NOT_FOUND',
      });
    }

    const baseBranch = base ?? await detectDefaultBranch(repo.path);

    try {
      // 1. Get diff to know which files changed
      const diffSummary = await getBranchDiff(repo.path, branch, baseBranch);

      // 2. Run analysis scoped to changed files
      const changedFilePaths = diffSummary.files.map(f => f.path);
      const analysisReport = await runAnalysis(repo.path, {
        branch,
        baseBranch,
        scopeToFiles: changedFilePaths,
      });

      // 3. Persist to database
      const record = insertAnalysis(
        repoId,
        branch,
        baseBranch,
        diffSummary,
        analysisReport
      );

      // 4. Return parsed result
      return reply.send({
        id: record.id,
        branch: record.branch,
        baseBranch: record.base_branch,
        diffStats: JSON.parse(record.diff_stats),
        analysisData: JSON.parse(record.analysis_data),
        createdAt: record.created_at,
      });
    } catch (err) {
      if (err instanceof BranchNotFoundError) {
        return reply.status(404).send({
          error: err.message,
          code: 'BRANCH_NOT_FOUND',
        });
      }
      return reply.status(500).send({
        error: 'Analysis failed',
        code: 'ANALYSIS_ERROR',
      });
    }
  }
);

// GET /api/repos/:repoId/branches/:branch/analysis
fastify.get<{ Params: BranchParams }>(
  '/api/repos/:repoId/branches/:branch/analysis',
  async (request, reply) => {
    const { repoId, branch } = request.params;

    const repo = getRepoById(repoId);
    if (!repo) {
      return reply.status(404).send({
        error: 'Repository not found',
        code: 'REPO_NOT_FOUND',
      });
    }

    const record = getLatestAnalysis(repoId, branch);
    if (!record) {
      return reply.status(404).send({
        error: `No analysis found for branch ${branch}`,
        code: 'ANALYSIS_NOT_FOUND',
      });
    }

    return reply.send({
      id: record.id,
      branch: record.branch,
      baseBranch: record.base_branch,
      diffStats: JSON.parse(record.diff_stats),
      analysisData: JSON.parse(record.analysis_data),
      createdAt: record.created_at,
    });
  }
);
```

**Step 3: Ensure analyses table exists in schema**

The `analyses` table is already defined in the PRD schema (EPIC-001). Verify it includes all required columns:

```sql
CREATE TABLE IF NOT EXISTS analyses (
  id INTEGER PRIMARY KEY,
  repo_id TEXT REFERENCES repos(id),
  branch TEXT,
  base_branch TEXT,
  diff_stats TEXT,           -- JSON (BranchDiffSummary)
  analysis_data TEXT,        -- JSON (AnalysisReport)
  created_at TEXT
);

CREATE INDEX IF NOT EXISTS idx_analyses_repo_branch
  ON analyses(repo_id, branch, created_at DESC);
```

### 3.3 API Contract

**POST `/api/repos/:repoId/branches/:branch/analyze?base=main`**

Response `200`:
```json
{
  "id": 42,
  "branch": "feature/auth",
  "baseBranch": "main",
  "diffStats": {
    "branch": "feature/auth",
    "baseBranch": "main",
    "filesChanged": 5,
    "totalInsertions": 120,
    "totalDeletions": 30,
    "files": [...]
  },
  "analysisData": {
    "complexity": { ... },
    "duplication": { ... },
    "errorPatterns": { ... }
  },
  "createdAt": "2026-02-23T10:30:00.000Z"
}
```

**GET `/api/repos/:repoId/branches/:branch/analysis`**

Response `200` (same shape as POST response).

Response `404`:
```json
{ "error": "No analysis found for branch feature/new", "code": "ANALYSIS_NOT_FOUND" }
```

---

## 4. Definition of Done (The Gate)
- [ ] `POST /api/repos/:repoId/branches/:branch/analyze` triggers the analyzer on changed files and returns results.
- [ ] Analysis results are persisted in the `analyses` table with branch, base_branch, diff_stats, and analysis_data.
- [ ] `GET /api/repos/:repoId/branches/:branch/analysis` returns the most recent analysis or 404.
- [ ] `base` query parameter overrides auto-detected default branch.
- [ ] 404 returned for unknown repos and branches.
- [ ] `created_at` timestamp is stored and returned.
- [ ] An index on `(repo_id, branch, created_at DESC)` exists for efficient lookups.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
