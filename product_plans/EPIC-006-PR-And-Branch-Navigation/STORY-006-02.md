---
id: STORY-006-02
parent_epic: EPIC-006
status: Draft
actor: Backend Developer
complexity: Low (1 file)
---
# STORY-006-02: Git History Utilities

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** git history utility functions that list branches with metadata, retrieve commit logs, and identify the current branch,
**So that** the branch listing API can provide rich branch information including tracking status, last commit date, and ahead/behind counts.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `listBranches(repoPath: string): Promise<BranchInfo[]>` that runs `git branch -a --format='%(refname:short) %(upstream:track) %(committerdate:iso8601) %(objectname:short)'` and parses the output.
- **Requirement 2**: Parse each line to extract: branch name, tracking status (ahead/behind counts), last commit date (ISO 8601), and short commit hash.
- **Requirement 3**: Implement `getBranchLog(repoPath: string, branch: string, limit?: number): Promise<CommitLogEntry[]>` that runs `git log {branch} --oneline -n {limit}` (default limit: 20) and returns parsed entries.
- **Requirement 4**: Implement `getCurrentBranch(repoPath: string): Promise<string>` that runs `git rev-parse --abbrev-ref HEAD` and returns the current branch name.
- **Requirement 5**: Return `BranchInfo[]` sorted with the current branch first, then remaining branches sorted by `lastCommitDate` descending (most recently active first).
- **Requirement 6**: Handle detached HEAD state gracefully — `getCurrentBranch` returns `"HEAD"` and no branch is marked as current in the list.
- **Requirement 7**: Filter out remote tracking branches that are duplicates of local branches (e.g., if `main` and `origin/main` both exist, only show `main` but include tracking info).

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Git History Utilities

  Scenario: List all branches with metadata
    Given a git repo at "/tmp/test-repo" with branches "main", "feature/auth", "fix/typo"
    When I call listBranches("/tmp/test-repo")
    Then the result contains 3 BranchInfo entries
    And each entry has name, isCurrent, lastCommitDate, and lastCommitHash

  Scenario: Current branch is listed first
    Given the current branch is "feature/auth"
    When I call listBranches("/tmp/test-repo")
    Then the first entry has name "feature/auth" and isCurrent is true
    And all other entries have isCurrent as false

  Scenario: Branches sorted by last commit date
    Given "fix/typo" was last committed yesterday and "main" was last committed a week ago
    When I call listBranches("/tmp/test-repo")
    Then "feature/auth" (current) is first
    And "fix/typo" appears before "main" in the remaining entries

  Scenario: Parse ahead/behind tracking
    Given "feature/auth" is 3 ahead and 1 behind its upstream
    When I call listBranches("/tmp/test-repo")
    Then the "feature/auth" entry has ahead equal to 3 and behind equal to 1

  Scenario: Get branch commit log
    Given "feature/auth" has 5 commits
    When I call getBranchLog("/tmp/test-repo", "feature/auth", 3)
    Then the result contains exactly 3 CommitLogEntry items
    And each entry has hash and message

  Scenario: Get current branch name
    Given the checked-out branch is "feature/auth"
    When I call getCurrentBranch("/tmp/test-repo")
    Then the result is "feature/auth"

  Scenario: Detached HEAD state
    Given the repo is in a detached HEAD state
    When I call getCurrentBranch("/tmp/test-repo")
    Then the result is "HEAD"
```

### 2.2 Verification Steps
- [ ] `listBranches` returns correct branch metadata for a fixture repo.
- [ ] Current branch appears first in the sorted output with `isCurrent: true`.
- [ ] Non-current branches are sorted by `lastCommitDate` descending.
- [ ] Ahead/behind counts are parsed correctly from tracking info.
- [ ] `getBranchLog` returns the correct number of log entries.
- [ ] `getCurrentBranch` returns the correct branch name.
- [ ] Detached HEAD returns `"HEAD"` without errors.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/git/history.ts` (create)
- **Related Files**: `src/server/utils/exec.ts` (existing — shared shell exec utility)
- **New Files Needed**:
  - `src/server/git/history.ts`
  - `tests/server/git/history.test.ts` (unit tests)

### 3.2 Technical Logic

**Step 1: Define types**

```typescript
// src/server/git/history.ts

export interface BranchInfo {
  name: string;
  isCurrent: boolean;
  lastCommitDate: string;   // ISO 8601
  lastCommitHash: string;   // Short hash (7-8 chars)
  ahead: number;            // Commits ahead of upstream
  behind: number;           // Commits behind upstream
}

export interface CommitLogEntry {
  hash: string;             // Short commit hash
  message: string;          // First line of commit message
}
```

**Step 2: Implement `getCurrentBranch`**

```typescript
import { execCommand } from '../utils/exec.js';

export async function getCurrentBranch(repoPath: string): Promise<string> {
  try {
    const result = await execCommand(
      'git rev-parse --abbrev-ref HEAD',
      { cwd: repoPath }
    );
    return result.stdout.trim();
  } catch {
    throw new Error(`Failed to get current branch at: ${repoPath}`);
  }
}
```

**Step 3: Implement `listBranches`**

```typescript
export async function listBranches(repoPath: string): Promise<BranchInfo[]> {
  const currentBranch = await getCurrentBranch(repoPath);

  // Get local branches with formatting
  // %(upstream:track) outputs like "[ahead 3, behind 1]" or "[ahead 2]" or ""
  const result = await execCommand(
    `git branch --format='%(refname:short)\t%(upstream:track)\t%(committerdate:iso8601)\t%(objectname:short)'`,
    { cwd: repoPath }
  );

  const output = result.stdout.trim();
  if (!output) return [];

  const branches: BranchInfo[] = [];

  for (const line of output.split('\n')) {
    // Remove surrounding single quotes if present (some shells keep them)
    const cleanLine = line.replace(/^'|'$/g, '').trim();
    if (!cleanLine) continue;

    const parts = cleanLine.split('\t');
    if (parts.length < 4) continue;

    const name = parts[0].trim();
    const trackingRaw = parts[1].trim();
    const dateRaw = parts[2].trim();
    const hash = parts[3].trim();

    const { ahead, behind } = parseTrackingInfo(trackingRaw);

    branches.push({
      name,
      isCurrent: name === currentBranch,
      lastCommitDate: dateRaw,
      lastCommitHash: hash,
      ahead,
      behind,
    });
  }

  // Sort: current branch first, then by lastCommitDate descending
  branches.sort((a, b) => {
    if (a.isCurrent) return -1;
    if (b.isCurrent) return 1;
    // Sort by date descending (most recent first)
    return new Date(b.lastCommitDate).getTime() - new Date(a.lastCommitDate).getTime();
  });

  return branches;
}
```

**Step 4: Parse tracking info**

```typescript
function parseTrackingInfo(trackingRaw: string): { ahead: number; behind: number } {
  let ahead = 0;
  let behind = 0;

  if (!trackingRaw) return { ahead, behind };

  // Tracking info format: "[ahead 3]", "[behind 1]", "[ahead 3, behind 1]", "[gone]"
  const aheadMatch = trackingRaw.match(/ahead\s+(\d+)/);
  const behindMatch = trackingRaw.match(/behind\s+(\d+)/);

  if (aheadMatch) ahead = parseInt(aheadMatch[1], 10);
  if (behindMatch) behind = parseInt(behindMatch[1], 10);

  return { ahead, behind };
}
```

**Step 5: Implement `getBranchLog`**

```typescript
export async function getBranchLog(
  repoPath: string,
  branch: string,
  limit: number = 20
): Promise<CommitLogEntry[]> {
  const result = await execCommand(
    `git log ${branch} --oneline -n ${limit}`,
    { cwd: repoPath }
  );

  const output = result.stdout.trim();
  if (!output) return [];

  const entries: CommitLogEntry[] = [];
  for (const line of output.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    // --oneline format: "abc1234 Commit message here"
    const spaceIndex = trimmed.indexOf(' ');
    if (spaceIndex === -1) {
      entries.push({ hash: trimmed, message: '' });
    } else {
      entries.push({
        hash: trimmed.substring(0, spaceIndex),
        message: trimmed.substring(spaceIndex + 1),
      });
    }
  }

  return entries;
}
```

### 3.3 API Contract
N/A — this is an internal module consumed by `src/server/api/branches.ts` (STORY-006-03). No HTTP endpoints.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/git/history.ts` exists and exports `listBranches`, `getBranchLog`, `getCurrentBranch`, `BranchInfo`, `CommitLogEntry`.
- [ ] `listBranches` correctly parses `git branch --format` output into `BranchInfo[]`.
- [ ] Current branch appears first in the list with `isCurrent: true`.
- [ ] Remaining branches are sorted by `lastCommitDate` descending.
- [ ] Ahead/behind counts are correctly parsed from tracking info (including missing/empty tracking).
- [ ] `getBranchLog` returns correctly parsed commit entries with hash and message.
- [ ] `getCurrentBranch` returns the active branch name or `"HEAD"` for detached state.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
