---
id: STORY-005-04
parent_epic: EPIC-005
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-005-04: Complexity Analysis (Lizard CLI)

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a module that wraps the Lizard CLI to measure cyclomatic complexity per function across the repository,
**So that** the analyzer engine can flag overly complex functions and provide actionable data for refactoring.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `analyzeComplexity(repoPath: string, config: ComplexityConfig): Promise<ComplexityResult>` that invokes Lizard CLI and parses its JSON output.
- **Requirement 2**: Shell command to execute: `lizard {repoPath} --json` with optional language filters: `-l python -l javascript` etc., based on detected languages.
- **Requirement 3**: Parse Lizard JSON output to extract per-function data: file path, function name, cyclomatic complexity (CCN), NLOC (non-comment lines of code), token count, start line, and end line.
- **Requirement 4**: Apply configurable thresholds: `warnThreshold` (default: 10) and `failThreshold` (default: 15). Functions with complexity > `failThreshold` produce status=fail; functions with complexity > `warnThreshold` produce status=warn.
- **Requirement 5**: Graceful fallback: if Lizard is not installed (command not found), return `{ status: 'skipped', available: false, reason: 'Lizard not installed. Run: pip install lizard' }` instead of throwing an error.
- **Requirement 6**: Set a timeout of 60 seconds on the Lizard process. If it times out, return status=skipped with reason explaining the timeout.
- **Requirement 7**: Exclude directories in `SKIP_DIRS` by passing `--exclude` flags to Lizard: `--exclude "node_modules/*" --exclude ".git/*"` etc.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Complexity Analysis via Lizard CLI

  Scenario: Successful complexity analysis
    Given Lizard is installed and a repo has functions with varying complexity
    When I call analyzeComplexity on the repo
    Then the result contains per-function complexity data
    And functions with CCN > 15 have status "fail"
    And functions with CCN between 11 and 15 have status "warn"
    And functions with CCN <= 10 are not flagged

  Scenario: Lizard not installed
    Given Lizard CLI is not available on the system PATH
    When I call analyzeComplexity on the repo
    Then the result status is "skipped"
    And available is false
    And reason contains "Lizard not installed"

  Scenario: Lizard times out
    Given Lizard CLI takes longer than 60 seconds to complete
    When I call analyzeComplexity on the repo
    Then the result status is "skipped"
    And reason contains "timed out"

  Scenario: Custom thresholds
    Given a function with cyclomatic complexity of 12
    And warnThreshold is set to 10 and failThreshold is set to 20
    When I call analyzeComplexity
    Then the function is flagged as "warn" (not "fail")

  Scenario: Exclude directories
    Given a repo with files in both "src/" and "node_modules/"
    When I call analyzeComplexity
    Then only files from "src/" appear in the results
```

### 2.2 Verification Steps
- [ ] `analyzeComplexity` returns function-level complexity data when Lizard is available.
- [ ] Correct thresholds are applied: warn vs fail.
- [ ] Graceful fallback when Lizard is not installed (no crash, informative message).
- [ ] Timeout is enforced at 60 seconds.
- [ ] `SKIP_DIRS` directories are excluded from Lizard's scan.
- [ ] JSON output from Lizard is correctly parsed into typed results.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/analyzer/complexity.ts` (create)
- **Related Files**:
  - `src/server/analyzer/languages/detector.ts` (reuse `SKIP_DIRS`)
  - `src/server/utils/exec.ts` (shell execution utility, may need to create if not yet available)
- **New Files Needed**:
  - `src/server/analyzer/complexity.ts`
  - `src/server/utils/exec.ts` (if not already created by a prior story)
  - `tests/analyzer/complexity.test.ts`

### 3.2 Technical Logic

**Step 1: Define types and config**

```typescript
// src/server/analyzer/complexity.ts

export interface ComplexityConfig {
  warnThreshold: number;   // default: 10
  failThreshold: number;   // default: 15
  timeoutMs: number;       // default: 60000
}

export const DEFAULT_COMPLEXITY_CONFIG: ComplexityConfig = {
  warnThreshold: 10,
  failThreshold: 15,
  timeoutMs: 60_000,
};

export interface FunctionComplexity {
  file: string;          // relative path
  name: string;          // function name
  complexity: number;    // cyclomatic complexity (CCN)
  nloc: number;          // non-comment lines of code
  tokenCount: number;
  startLine: number;
  endLine: number;
  flag: 'warn' | 'fail' | null;
}

export interface ComplexityResult {
  status: 'pass' | 'warn' | 'fail' | 'skipped';
  available: boolean;
  reason?: string;
  functions: FunctionComplexity[];
  summary: {
    totalFunctions: number;
    avgComplexity: number;
    maxComplexity: number;
    warnCount: number;
    failCount: number;
  };
}
```

**Step 2: Create shell execution utility**

```typescript
// src/server/utils/exec.ts

import { execFile } from 'node:child_process';
import { promisify } from 'node:util';

const execFileAsync = promisify(execFile);

export interface ExecResult {
  stdout: string;
  stderr: string;
}

export async function execCommand(
  command: string,
  args: string[],
  options: { timeoutMs?: number; cwd?: string } = {}
): Promise<ExecResult> {
  const { timeoutMs = 60_000, cwd } = options;
  const result = await execFileAsync(command, args, {
    timeout: timeoutMs,
    cwd,
    maxBuffer: 10 * 1024 * 1024, // 10MB buffer for large repos
  });
  return { stdout: result.stdout, stderr: result.stderr };
}

export async function isCommandAvailable(command: string): Promise<boolean> {
  try {
    await execFileAsync('which', [command]);
    return true;
  } catch {
    return false;
  }
}
```

**Step 3: Build Lizard command and parse output**

```typescript
import { relative } from 'node:path';
import { execCommand, isCommandAvailable } from '../utils/exec.js';
import { SKIP_DIRS } from './languages/detector.js';

// Lizard JSON output structure (partial)
interface LizardJsonOutput {
  functions: Array<{
    name: string;
    long_name: string;
    filename: string;
    nloc: number;
    cyclomatic_complexity: number;
    token_count: number;
    start_line: number;
    end_line: number;
  }>;
}

// Lizard language names mapped from our language names
const LIZARD_LANGUAGE_MAP: Record<string, string> = {
  TypeScript: 'javascript',  // Lizard uses JS parser for TS
  JavaScript: 'javascript',
  Python: 'python',
  Go: 'go',
  Java: 'java',
  Rust: 'rust',
  'C#': 'csharp',
  Ruby: 'ruby',
};

function buildLizardArgs(
  repoPath: string,
  languages?: string[]
): string[] {
  const args = [repoPath, '--json'];

  // Add language filters
  if (languages && languages.length > 0) {
    const lizardLangs = new Set<string>();
    for (const lang of languages) {
      const lizardLang = LIZARD_LANGUAGE_MAP[lang];
      if (lizardLang) lizardLangs.add(lizardLang);
    }
    for (const ll of lizardLangs) {
      args.push('-l', ll);
    }
  }

  // Add exclude patterns for SKIP_DIRS
  for (const dir of SKIP_DIRS) {
    args.push('--exclude', `${dir}/*`);
  }

  return args;
}
```

**Step 4: Implement analyzeComplexity**

```typescript
export async function analyzeComplexity(
  repoPath: string,
  config: ComplexityConfig = DEFAULT_COMPLEXITY_CONFIG,
  languages?: string[]
): Promise<ComplexityResult> {
  // Check if Lizard is available
  const available = await isCommandAvailable('lizard');
  if (!available) {
    return {
      status: 'skipped',
      available: false,
      reason: 'Lizard not installed. Run: pip install lizard',
      functions: [],
      summary: {
        totalFunctions: 0,
        avgComplexity: 0,
        maxComplexity: 0,
        warnCount: 0,
        failCount: 0,
      },
    };
  }

  // Execute Lizard
  const args = buildLizardArgs(repoPath, languages);
  let stdout: string;
  try {
    const result = await execCommand('lizard', args, {
      timeoutMs: config.timeoutMs,
    });
    stdout = result.stdout;
  } catch (error: any) {
    if (error.killed || error.signal === 'SIGTERM') {
      return {
        status: 'skipped',
        available: true,
        reason: `Lizard timed out after ${config.timeoutMs / 1000}s`,
        functions: [],
        summary: {
          totalFunctions: 0,
          avgComplexity: 0,
          maxComplexity: 0,
          warnCount: 0,
          failCount: 0,
        },
      };
    }
    throw error;
  }

  // Parse JSON output
  let parsed: LizardJsonOutput;
  try {
    parsed = JSON.parse(stdout);
  } catch {
    return {
      status: 'skipped',
      available: true,
      reason: 'Failed to parse Lizard JSON output',
      functions: [],
      summary: {
        totalFunctions: 0,
        avgComplexity: 0,
        maxComplexity: 0,
        warnCount: 0,
        failCount: 0,
      },
    };
  }

  // Map to our types and apply thresholds
  let warnCount = 0;
  let failCount = 0;
  let totalComplexity = 0;
  let maxComplexity = 0;

  const functions: FunctionComplexity[] = parsed.functions.map(fn => {
    const ccn = fn.cyclomatic_complexity;
    totalComplexity += ccn;
    if (ccn > maxComplexity) maxComplexity = ccn;

    let flag: 'warn' | 'fail' | null = null;
    if (ccn > config.failThreshold) {
      flag = 'fail';
      failCount++;
    } else if (ccn > config.warnThreshold) {
      flag = 'warn';
      warnCount++;
    }

    return {
      file: relative(repoPath, fn.filename),
      name: fn.name,
      complexity: ccn,
      nloc: fn.nloc,
      tokenCount: fn.token_count,
      startLine: fn.start_line,
      endLine: fn.end_line,
      flag,
    };
  });

  // Only include flagged functions in output (keep result concise)
  const flaggedFunctions = functions.filter(f => f.flag !== null);

  // Determine overall status
  let status: 'pass' | 'warn' | 'fail' = 'pass';
  if (failCount > 0) status = 'fail';
  else if (warnCount > 0) status = 'warn';

  return {
    status,
    available: true,
    functions: flaggedFunctions,
    summary: {
      totalFunctions: functions.length,
      avgComplexity: functions.length > 0
        ? Math.round((totalComplexity / functions.length) * 10) / 10
        : 0,
      maxComplexity,
      warnCount,
      failCount,
    },
  };
}
```

### 3.3 API Contract
N/A â€” this is an internal module consumed by the analysis engine (STORY-005-08). No HTTP endpoints.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/analyzer/complexity.ts` exists and exports `analyzeComplexity`, `ComplexityConfig`, `ComplexityResult`, and related types.
- [ ] `src/server/utils/exec.ts` exists and exports `execCommand` and `isCommandAvailable`.
- [ ] When Lizard is installed, `analyzeComplexity` returns per-function complexity data.
- [ ] Functions are correctly flagged as `warn` or `fail` based on configurable thresholds.
- [ ] When Lizard is not installed, returns `status: 'skipped'` with helpful installation message.
- [ ] Timeout is enforced; timed-out runs return `status: 'skipped'` with reason.
- [ ] Directories in `SKIP_DIRS` are excluded from the Lizard scan.
- [ ] Summary statistics (totalFunctions, avgComplexity, maxComplexity) are calculated correctly.
- [ ] Unit tests pass (with mocked Lizard output for CI environments).
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
