---
id: STORY-005-02
parent_epic: EPIC-005
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-005-02: File & Function Size Checker

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a module that scans repository source files for excessive file length and overly long functions,
**So that** the analyzer engine can flag files and functions that exceed configurable size thresholds, encouraging smaller, more maintainable code units.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `checkFileSizes(repoPath: string, config: SizeConfig): Promise<SizeCheckResult>` that scans all source files (using `EXTENSION_MAP` and `SKIP_DIRS` from STORY-005-01) and flags files exceeding `config.fileMaxLines` (default: 400).
- **Requirement 2**: Implement `checkFunctionSizes(repoPath: string, config: SizeConfig): Promise<SizeCheckResult>` that uses regex heuristics per language to detect function boundaries and flags functions exceeding `config.functionMaxLines` (default: 50).
- **Requirement 3**: Function detection regex patterns by language family:
  - **JS/TS**: `function\s+(\w+)`, `(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(`, `(\w+)\s*\([^)]*\)\s*\{` (method shorthand)
  - **Python**: `def\s+(\w+)`
  - **Go**: `func\s+(?:\([^)]*\)\s*)?(\w+)`
  - **Rust**: `(?:pub\s+)?fn\s+(\w+)`
  - **Java/C#**: `(?:public|private|protected|static|\s)+\s+\w+\s+(\w+)\s*\(`
  - **Ruby**: `def\s+(\w+)`
- **Requirement 4**: Function length is measured from the opening line to the closing brace/dedent. For brace-based languages, use a brace-counting heuristic. For Python/Ruby, count until the next function definition or dedent to the same level.
- **Requirement 5**: Return an overall `status` of `pass`, `warn`, or `fail` based on thresholds: any file exceeding `fileMaxLines` sets status to at least `warn`; any function exceeding `functionMaxLines * 2` (100 lines default) sets status to `fail`.
- **Requirement 6**: Export a unified `checkSizes(repoPath, config)` function that runs both checks and merges results.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: File and Function Size Checking

  Scenario: File exceeds max lines
    Given a file "src/big.ts" with 500 lines
    And the fileMaxLines config is 400
    When I call checkFileSizes on the repo
    Then the result contains a file entry for "src/big.ts" with lines=500
    And the overall status is "warn"

  Scenario: File within threshold
    Given a file "src/small.ts" with 100 lines
    And the fileMaxLines config is 400
    When I call checkFileSizes on the repo
    Then "src/small.ts" does not appear in the flagged files list
    And the overall status is "pass"

  Scenario: Function exceeds max lines in TypeScript
    Given a file "src/service.ts" containing a function "processData" that is 80 lines long
    And the functionMaxLines config is 50
    When I call checkFunctionSizes on the repo
    Then the result contains a function entry { name: "processData", lines: 80 }
    And the overall status is "warn"

  Scenario: Function drastically exceeds threshold
    Given a file "src/monolith.ts" containing a function "doEverything" that is 120 lines long
    And the functionMaxLines config is 50
    When I call checkFunctionSizes on the repo
    Then the overall status is "fail"

  Scenario: Python function detection
    Given a file "app.py" containing "def process_data():" spanning 60 lines
    And the functionMaxLines config is 50
    When I call checkFunctionSizes on the repo
    Then the result contains { name: "process_data", lines: 60 }

  Scenario: Skip excluded directories
    Given a file "node_modules/dep/index.js" with 1000 lines
    When I call checkFileSizes on the repo
    Then no files from node_modules appear in the results
```

### 2.2 Verification Steps
- [ ] `checkFileSizes` correctly identifies files exceeding the threshold.
- [ ] `checkFunctionSizes` detects functions in JS/TS, Python, Go, Rust, Java, C#, and Ruby.
- [ ] Function line counts are approximately correct (within 5 lines tolerance for heuristic).
- [ ] Excluded directories are never scanned.
- [ ] Status escalation logic works: pass -> warn -> fail.
- [ ] Default config values are applied when no config is provided.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/analyzer/file-size.ts` (create)
- **Related Files**: `src/server/analyzer/languages/detector.ts` (reuse `EXTENSION_MAP`, `SKIP_DIRS`)
- **New Files Needed**:
  - `src/server/analyzer/file-size.ts`
  - `tests/analyzer/file-size.test.ts`

### 3.2 Technical Logic

**Step 1: Define types and config**

```typescript
// src/server/analyzer/file-size.ts

import { readFile } from 'node:fs/promises';
import { join, extname } from 'node:path';
import { EXTENSION_MAP, SKIP_DIRS } from './languages/detector.js';

export interface SizeConfig {
  fileMaxLines: number;       // default: 400
  functionMaxLines: number;   // default: 50
}

export const DEFAULT_SIZE_CONFIG: SizeConfig = {
  fileMaxLines: 400,
  functionMaxLines: 50,
};

export type CheckStatus = 'pass' | 'warn' | 'fail';

export interface FunctionInfo {
  name: string;
  lines: number;
  startLine: number;
}

export interface FileSizeEntry {
  path: string;         // relative to repoPath
  lines: number;
  functions: FunctionInfo[];
}

export interface SizeCheckResult {
  status: CheckStatus;
  files: FileSizeEntry[];
  totalFilesScanned: number;
  filesOverThreshold: number;
  functionsOverThreshold: number;
}
```

**Step 2: Implement file size checking**

```typescript
import { readdir } from 'node:fs/promises';
import { relative } from 'node:path';

async function collectSourceFiles(
  dir: string,
  repoPath: string,
  result: string[]
): Promise<void> {
  let entries;
  try {
    entries = await readdir(dir, { withFileTypes: true });
  } catch {
    return;
  }
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      if (!SKIP_DIRS.has(entry.name)) {
        await collectSourceFiles(fullPath, repoPath, result);
      }
    } else if (entry.isFile()) {
      const ext = extname(entry.name).toLowerCase();
      if (EXTENSION_MAP[ext]) {
        result.push(fullPath);
      }
    }
  }
}

export async function checkFileSizes(
  repoPath: string,
  config: SizeConfig = DEFAULT_SIZE_CONFIG
): Promise<SizeCheckResult> {
  const filePaths: string[] = [];
  await collectSourceFiles(repoPath, repoPath, filePaths);

  const flaggedFiles: FileSizeEntry[] = [];
  for (const filePath of filePaths) {
    const content = await readFile(filePath, 'utf-8');
    const lineCount = content.split('\n').length;
    if (lineCount > config.fileMaxLines) {
      flaggedFiles.push({
        path: relative(repoPath, filePath),
        lines: lineCount,
        functions: [],
      });
    }
  }

  const status: CheckStatus = flaggedFiles.length > 0 ? 'warn' : 'pass';
  return {
    status,
    files: flaggedFiles,
    totalFilesScanned: filePaths.length,
    filesOverThreshold: flaggedFiles.length,
    functionsOverThreshold: 0,
  };
}
```

**Step 3: Implement function detection regex patterns**

```typescript
interface FunctionPattern {
  regex: RegExp;
  nameGroup: number;  // capture group index for function name
}

const FUNCTION_PATTERNS: Record<string, FunctionPattern[]> = {
  TypeScript: [
    { regex: /function\s+(\w+)/g, nameGroup: 1 },
    { regex: /(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(/g, nameGroup: 1 },
    { regex: /(\w+)\s*\([^)]*\)\s*\{/g, nameGroup: 1 },
  ],
  JavaScript: [
    { regex: /function\s+(\w+)/g, nameGroup: 1 },
    { regex: /(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(/g, nameGroup: 1 },
    { regex: /(\w+)\s*\([^)]*\)\s*\{/g, nameGroup: 1 },
  ],
  Python: [
    { regex: /def\s+(\w+)/g, nameGroup: 1 },
  ],
  Go: [
    { regex: /func\s+(?:\([^)]*\)\s*)?(\w+)/g, nameGroup: 1 },
  ],
  Rust: [
    { regex: /(?:pub\s+)?fn\s+(\w+)/g, nameGroup: 1 },
  ],
  Java: [
    { regex: /(?:public|private|protected|static|\s)+\s+\w+\s+(\w+)\s*\(/g, nameGroup: 1 },
  ],
  'C#': [
    { regex: /(?:public|private|protected|static|\s)+\s+\w+\s+(\w+)\s*\(/g, nameGroup: 1 },
  ],
  Ruby: [
    { regex: /def\s+(\w+)/g, nameGroup: 1 },
  ],
};
```

**Step 4: Implement function size measurement**

```typescript
function measureFunctionLength(
  lines: string[],
  startLine: number,
  language: string
): number {
  // For brace-based languages: count brace depth
  const braceLanguages = ['TypeScript', 'JavaScript', 'Go', 'Rust', 'Java', 'C#'];
  if (braceLanguages.includes(language)) {
    let depth = 0;
    let foundOpen = false;
    for (let i = startLine; i < lines.length; i++) {
      const line = lines[i];
      for (const ch of line) {
        if (ch === '{') { depth++; foundOpen = true; }
        if (ch === '}') { depth--; }
      }
      if (foundOpen && depth <= 0) {
        return i - startLine + 1;
      }
    }
    return lines.length - startLine; // unclosed — count to EOF
  }

  // For indentation-based languages (Python, Ruby):
  // Count until next def/function at same or lower indent, or EOF
  const indentOfDef = lines[startLine].search(/\S/);
  for (let i = startLine + 1; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim() === '') continue; // skip blank lines
    const currentIndent = line.search(/\S/);
    if (currentIndent <= indentOfDef && /^(def |class )/.test(line.trim())) {
      return i - startLine;
    }
  }
  return lines.length - startLine;
}
```

**Step 5: Implement checkFunctionSizes**

```typescript
export async function checkFunctionSizes(
  repoPath: string,
  config: SizeConfig = DEFAULT_SIZE_CONFIG
): Promise<SizeCheckResult> {
  const filePaths: string[] = [];
  await collectSourceFiles(repoPath, repoPath, filePaths);

  const flaggedFiles: FileSizeEntry[] = [];
  let functionsOverThreshold = 0;

  for (const filePath of filePaths) {
    const content = await readFile(filePath, 'utf-8');
    const lines = content.split('\n');
    const ext = extname(filePath).toLowerCase();
    const language = EXTENSION_MAP[ext];
    if (!language) continue;

    const patterns = FUNCTION_PATTERNS[language];
    if (!patterns) continue;

    const functions: FunctionInfo[] = [];
    for (const pattern of patterns) {
      const regex = new RegExp(pattern.regex.source, pattern.regex.flags);
      let match;
      while ((match = regex.exec(content)) !== null) {
        const name = match[pattern.nameGroup];
        // Calculate line number of match
        const startLine = content.substring(0, match.index).split('\n').length - 1;
        const fnLines = measureFunctionLength(lines, startLine, language);
        if (fnLines > config.functionMaxLines) {
          functions.push({ name, lines: fnLines, startLine: startLine + 1 });
          functionsOverThreshold++;
        }
      }
    }

    if (functions.length > 0) {
      flaggedFiles.push({
        path: relative(repoPath, filePath),
        lines: lines.length,
        functions,
      });
    }
  }

  // Status: fail if any function > 2x threshold, warn if any > 1x
  let status: CheckStatus = 'pass';
  const failThreshold = config.functionMaxLines * 2;
  for (const file of flaggedFiles) {
    for (const fn of file.functions) {
      if (fn.lines > failThreshold) { status = 'fail'; break; }
      if (fn.lines > config.functionMaxLines) { status = 'warn'; }
    }
    if (status === 'fail') break;
  }

  return {
    status,
    files: flaggedFiles,
    totalFilesScanned: filePaths.length,
    filesOverThreshold: 0,
    functionsOverThreshold,
  };
}
```

**Step 6: Unified check function**

```typescript
export async function checkSizes(
  repoPath: string,
  config: SizeConfig = DEFAULT_SIZE_CONFIG
): Promise<SizeCheckResult> {
  const [fileResult, fnResult] = await Promise.all([
    checkFileSizes(repoPath, config),
    checkFunctionSizes(repoPath, config),
  ]);

  // Merge: combine files from both results, escalate status
  const mergedFiles = new Map<string, FileSizeEntry>();
  for (const file of fileResult.files) {
    mergedFiles.set(file.path, { ...file });
  }
  for (const file of fnResult.files) {
    const existing = mergedFiles.get(file.path);
    if (existing) {
      existing.functions = file.functions;
    } else {
      mergedFiles.set(file.path, { ...file });
    }
  }

  const statusPriority: Record<CheckStatus, number> = { pass: 0, warn: 1, fail: 2 };
  const higherStatus = statusPriority[fileResult.status] >= statusPriority[fnResult.status]
    ? fileResult.status
    : fnResult.status;

  return {
    status: higherStatus,
    files: Array.from(mergedFiles.values()),
    totalFilesScanned: fileResult.totalFilesScanned,
    filesOverThreshold: fileResult.filesOverThreshold,
    functionsOverThreshold: fnResult.functionsOverThreshold,
  };
}
```

### 3.3 API Contract
N/A — this is an internal module consumed by the analysis engine (STORY-005-08). No HTTP endpoints.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/analyzer/file-size.ts` exists and exports `checkFileSizes`, `checkFunctionSizes`, `checkSizes`, and all related types.
- [ ] Files exceeding `fileMaxLines` are flagged with correct line counts.
- [ ] Functions exceeding `functionMaxLines` are detected across all 8 supported languages using regex heuristics.
- [ ] Function line counts are approximately correct (within 5 lines tolerance).
- [ ] Status escalation: `pass` -> `warn` (over threshold) -> `fail` (over 2x threshold).
- [ ] Excluded directories (`node_modules`, `.git`, etc.) are never scanned.
- [ ] Default config values are applied when no config is provided.
- [ ] Unit tests pass covering file size, function size, and merged checks.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
