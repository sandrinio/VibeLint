---
id: STORY-005-06
parent_epic: EPIC-005
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-005-06: Dependency Detection

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a module that detects package manifests in a repository, counts dependencies, and optionally identifies newly added dependencies via git diff,
**So that** the analyzer engine can report on dependency count and flag newly introduced dependencies for review awareness.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `checkDependencies(repoPath: string): Promise<DependencyResult>` that scans for all supported package manifests and counts their dependencies.
- **Requirement 2**: Supported manifest files and how to count dependencies:
  - `package.json` (npm): count keys in `dependencies` + `devDependencies`
  - `requirements.txt` (Python): count non-empty, non-comment lines
  - `pyproject.toml` (Python): count entries under `[project.dependencies]` and `[project.optional-dependencies]`
  - `go.mod` (Go): count `require` directives
  - `Cargo.toml` (Rust): count entries under `[dependencies]` and `[dev-dependencies]`
  - `pom.xml` (Java): count `<dependency>` elements (simple regex count)
  - `build.gradle` (Java): count `implementation`, `api`, `compileOnly`, `testImplementation` lines
  - `*.csproj` (C#): count `<PackageReference>` elements
  - `Gemfile` (Ruby): count `gem '...'` lines
- **Requirement 3**: Implement `detectNewDependencies(repoPath: string, baseBranch: string): Promise<DependencyResult>` that uses `git diff {baseBranch}...HEAD -- {manifest}` to find newly added dependency lines.
- **Requirement 4**: If no git diff is available (not a git repo, no base branch, or no commits), just report the current dependency count with `newDeps: []`.
- **Requirement 5**: Overall status: `pass` (always pass, since this is informational). The engine may override to `warn` based on policy in the future.
- **Requirement 6**: Search for manifests only at the repo root and one level deep (monorepo packages). Do not recurse deeply.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Dependency Detection

  Scenario: Detect npm dependencies
    Given a repo with a package.json containing 10 dependencies and 5 devDependencies
    When I call checkDependencies on the repo
    Then the result includes a manifest entry for "package.json" with depCount=15

  Scenario: Detect Python dependencies
    Given a repo with a requirements.txt containing 8 dependency lines
    When I call checkDependencies on the repo
    Then the result includes a manifest entry for "requirements.txt" with depCount=8

  Scenario: Detect Go dependencies
    Given a repo with a go.mod containing 6 require directives
    When I call checkDependencies on the repo
    Then the result includes a manifest entry for "go.mod" with depCount=6

  Scenario: Detect multiple manifests
    Given a repo with both package.json and requirements.txt
    When I call checkDependencies on the repo
    Then the result contains entries for both manifests

  Scenario: Detect new dependencies via git diff
    Given a repo with a package.json where "axios" was added compared to "main" branch
    When I call detectNewDependencies with baseBranch="main"
    Then the result includes a manifest entry with newDeps containing "axios"

  Scenario: No git repo
    Given a directory that is not a git repository
    When I call detectNewDependencies with baseBranch="main"
    Then the result has newDeps as empty arrays for all manifests
    And no errors are thrown

  Scenario: No manifests found
    Given a repo with no recognized package manifest files
    When I call checkDependencies on the repo
    Then the result has an empty manifests array
```

### 2.2 Verification Steps
- [ ] All 9 manifest types are detected when present.
- [ ] Dependency counts are accurate for each manifest type.
- [ ] `detectNewDependencies` correctly identifies added lines in manifests via git diff.
- [ ] Graceful handling when not a git repo or no base branch exists.
- [ ] Manifests are searched at repo root and one level deep.
- [ ] Comments and blank lines are excluded from counts (requirements.txt, Gemfile).

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/analyzer/dependencies.ts` (create)
- **Related Files**:
  - `src/server/utils/exec.ts` (shell execution utility from STORY-005-04)
- **New Files Needed**:
  - `src/server/analyzer/dependencies.ts`
  - `tests/analyzer/dependencies.test.ts`

### 3.2 Technical Logic

**Step 1: Define types**

```typescript
// src/server/analyzer/dependencies.ts

import { readFile, readdir, access } from 'node:fs/promises';
import { join, basename } from 'node:path';
import { execCommand } from '../utils/exec.js';

export interface ManifestEntry {
  file: string;          // relative path to manifest
  type: string;          // 'npm' | 'pip' | 'pyproject' | 'go' | 'cargo' | 'maven' | 'gradle' | 'nuget' | 'gem'
  depCount: number;      // total dependency count
  newDeps: string[];     // newly added deps (from git diff)
}

export interface DependencyResult {
  status: 'pass' | 'warn' | 'fail';
  manifests: ManifestEntry[];
  totalDeps: number;
  totalNewDeps: number;
}
```

**Step 2: Define manifest parsers**

```typescript
interface ManifestParser {
  filename: string | RegExp;
  type: string;
  countDeps: (content: string) => number;
  extractDepNames?: (content: string) => string[];
}

const MANIFEST_PARSERS: ManifestParser[] = [
  {
    filename: 'package.json',
    type: 'npm',
    countDeps: (content) => {
      try {
        const pkg = JSON.parse(content);
        const deps = Object.keys(pkg.dependencies || {}).length;
        const devDeps = Object.keys(pkg.devDependencies || {}).length;
        return deps + devDeps;
      } catch { return 0; }
    },
    extractDepNames: (content) => {
      try {
        const pkg = JSON.parse(content);
        return [
          ...Object.keys(pkg.dependencies || {}),
          ...Object.keys(pkg.devDependencies || {}),
        ];
      } catch { return []; }
    },
  },
  {
    filename: 'requirements.txt',
    type: 'pip',
    countDeps: (content) => {
      return content.split('\n')
        .filter(line => line.trim() !== '' && !line.trim().startsWith('#'))
        .length;
    },
    extractDepNames: (content) => {
      return content.split('\n')
        .filter(line => line.trim() !== '' && !line.trim().startsWith('#'))
        .map(line => line.split(/[=<>!~\[]/)[0].trim())
        .filter(Boolean);
    },
  },
  {
    filename: 'pyproject.toml',
    type: 'pyproject',
    countDeps: (content) => {
      // Simple heuristic: count lines in [project.dependencies] section
      const depsMatch = content.match(/\[project\.dependencies\]\s*\n([\s\S]*?)(?=\n\[|$)/);
      if (!depsMatch) return 0;
      return depsMatch[1].split('\n')
        .filter(line => line.trim() !== '' && !line.trim().startsWith('#'))
        .length;
    },
  },
  {
    filename: 'go.mod',
    type: 'go',
    countDeps: (content) => {
      const requireBlock = content.match(/require\s*\(([\s\S]*?)\)/g);
      let count = 0;
      if (requireBlock) {
        for (const block of requireBlock) {
          count += block.split('\n')
            .filter(line => line.trim() !== '' && !line.trim().startsWith('//') && !line.includes('(') && !line.includes(')'))
            .length;
        }
      }
      // Also count single-line requires
      const singleRequires = content.match(/^require\s+\S+/gm);
      if (singleRequires) count += singleRequires.length;
      return count;
    },
  },
  {
    filename: 'Cargo.toml',
    type: 'cargo',
    countDeps: (content) => {
      let count = 0;
      const sections = content.match(/\[(dev-)?dependencies\]\s*\n([\s\S]*?)(?=\n\[|$)/g);
      if (sections) {
        for (const section of sections) {
          count += section.split('\n').slice(1)
            .filter(line => line.trim() !== '' && !line.trim().startsWith('#') && line.includes('='))
            .length;
        }
      }
      return count;
    },
  },
  {
    filename: 'pom.xml',
    type: 'maven',
    countDeps: (content) => {
      const matches = content.match(/<dependency>/g);
      return matches ? matches.length : 0;
    },
  },
  {
    filename: 'build.gradle',
    type: 'gradle',
    countDeps: (content) => {
      const depKeywords = /^\s*(implementation|api|compileOnly|runtimeOnly|testImplementation|testRuntimeOnly)\s+/gm;
      const matches = content.match(depKeywords);
      return matches ? matches.length : 0;
    },
  },
  {
    filename: /\.csproj$/,
    type: 'nuget',
    countDeps: (content) => {
      const matches = content.match(/<PackageReference/g);
      return matches ? matches.length : 0;
    },
  },
  {
    filename: 'Gemfile',
    type: 'gem',
    countDeps: (content) => {
      return content.split('\n')
        .filter(line => /^\s*gem\s+['"]/.test(line))
        .length;
    },
  },
];
```

**Step 3: Find manifest files**

```typescript
async function findManifests(repoPath: string): Promise<string[]> {
  const manifests: string[] = [];

  // Check repo root
  const rootEntries = await readdir(repoPath, { withFileTypes: true });
  for (const entry of rootEntries) {
    if (!entry.isFile()) continue;
    const matched = MANIFEST_PARSERS.some(p => {
      if (typeof p.filename === 'string') return entry.name === p.filename;
      return p.filename.test(entry.name);
    });
    if (matched) manifests.push(join(repoPath, entry.name));
  }

  // Check one level deep (monorepo packages)
  for (const entry of rootEntries) {
    if (!entry.isDirectory()) continue;
    if (['node_modules', '.git', 'dist', 'build', 'vendor'].includes(entry.name)) continue;
    try {
      const subEntries = await readdir(join(repoPath, entry.name), { withFileTypes: true });
      for (const sub of subEntries) {
        if (!sub.isFile()) continue;
        const matched = MANIFEST_PARSERS.some(p => {
          if (typeof p.filename === 'string') return sub.name === p.filename;
          return p.filename.test(sub.name);
        });
        if (matched) manifests.push(join(repoPath, entry.name, sub.name));
      }
    } catch { /* skip unreadable directories */ }
  }

  return manifests;
}

function getParser(filename: string): ManifestParser | undefined {
  const name = basename(filename);
  return MANIFEST_PARSERS.find(p => {
    if (typeof p.filename === 'string') return name === p.filename;
    return p.filename.test(name);
  });
}
```

**Step 4: Implement checkDependencies**

```typescript
import { relative } from 'node:path';

export async function checkDependencies(
  repoPath: string
): Promise<DependencyResult> {
  const manifestPaths = await findManifests(repoPath);
  const manifests: ManifestEntry[] = [];

  for (const manifestPath of manifestPaths) {
    const content = await readFile(manifestPath, 'utf-8');
    const parser = getParser(manifestPath);
    if (!parser) continue;

    manifests.push({
      file: relative(repoPath, manifestPath),
      type: parser.type,
      depCount: parser.countDeps(content),
      newDeps: [],
    });
  }

  const totalDeps = manifests.reduce((sum, m) => sum + m.depCount, 0);
  return { status: 'pass', manifests, totalDeps, totalNewDeps: 0 };
}
```

**Step 5: Implement detectNewDependencies with git diff**

```typescript
async function isGitRepo(repoPath: string): Promise<boolean> {
  try {
    await access(join(repoPath, '.git'));
    return true;
  } catch { return false; }
}

export async function detectNewDependencies(
  repoPath: string,
  baseBranch: string
): Promise<DependencyResult> {
  const baseResult = await checkDependencies(repoPath);

  if (!(await isGitRepo(repoPath))) {
    return baseResult;
  }

  // For each manifest, run git diff to find added lines
  for (const manifest of baseResult.manifests) {
    try {
      const { stdout } = await execCommand('git', [
        'diff',
        `${baseBranch}...HEAD`,
        '--',
        manifest.file,
      ], { cwd: repoPath, timeoutMs: 10_000 });

      // Parse diff: lines starting with "+" (but not "+++") are additions
      const addedLines = stdout.split('\n')
        .filter(line => line.startsWith('+') && !line.startsWith('+++'))
        .map(line => line.substring(1).trim())
        .filter(line => line !== '');

      // Extract dependency names from added lines based on manifest type
      const parser = getParser(join(repoPath, manifest.file));
      if (parser && parser.extractDepNames) {
        const allDeps = parser.extractDepNames(addedLines.join('\n'));
        manifest.newDeps = allDeps;
      } else {
        // For non-JSON manifests, added lines are likely dep names
        manifest.newDeps = addedLines.filter(l => !l.startsWith('#') && !l.startsWith('//'));
      }
    } catch {
      // Git diff failed (no common ancestor, branch doesn't exist, etc.)
      // Leave newDeps as empty
    }
  }

  const totalNewDeps = baseResult.manifests.reduce((sum, m) => sum + m.newDeps.length, 0);
  return { ...baseResult, totalNewDeps };
}
```

### 3.3 API Contract
N/A â€” this is an internal module consumed by the analysis engine (STORY-005-08). No HTTP endpoints.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/analyzer/dependencies.ts` exists and exports `checkDependencies`, `detectNewDependencies`, and all related types.
- [ ] All 9 manifest types are correctly detected and dependency counts are accurate.
- [ ] `package.json` parser counts both `dependencies` and `devDependencies`.
- [ ] `requirements.txt` parser skips comments and blank lines.
- [ ] `detectNewDependencies` uses git diff to identify added dependencies.
- [ ] Graceful handling when not a git repo or base branch does not exist.
- [ ] Manifests are found at repo root and one directory level deep.
- [ ] Unit tests pass covering all manifest types and git diff scenarios.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
