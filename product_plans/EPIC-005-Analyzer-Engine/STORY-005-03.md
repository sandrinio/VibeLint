---
id: STORY-005-03
parent_epic: EPIC-005
status: Draft
actor: Backend Developer
complexity: Medium (2-3 files)
---
# STORY-005-03: Error Handling Pattern Detector

## 1. The Spec (The Contract)

### 1.1 User Story
**As a** Backend Developer,
**I want** a module that scans repository source files for error handling anti-patterns using regex-based detection per language,
**So that** the analyzer engine can identify empty catch blocks, swallowed errors, bare exceptions, and other common error handling mistakes that degrade code reliability.

### 1.2 Detailed Requirements
- **Requirement 1**: Implement `checkErrorHandling(repoPath: string, languages: string[]): Promise<ErrorPatternResult>` that scans source files for known anti-patterns, filtering by the detected languages.
- **Requirement 2**: Detect the following anti-patterns per language:
  - **Empty catch blocks** (JS/TS/Java/C#): `catch\s*\([^)]*\)\s*\{\s*\}` — a catch block with no code inside.
  - **Bare except** (Python): `except:\s*$` — catching all exceptions without specifying a type.
  - **Ignored errors** (Go): `if\s+err\s*!=\s*nil\s*\{\s*\}` — checking for an error but doing nothing with it.
  - **Swallowed errors** (JS/TS): catch blocks that only contain `console.log` / `console.error` / `console.warn` with no rethrow — detect via multiline regex or line-by-line scanning.
  - **Missing error handling** (JS/TS): `async` functions without any `try` or `.catch` — heuristic: if an async function body has no `try` keyword and no `.catch(` call, flag it as a warning.
- **Requirement 3**: Each detected issue includes: `file` (relative path), `line` (line number), `pattern` (human-readable name like "Empty catch block"), `severity` ("error" | "warning").
- **Requirement 4**: Overall status: `fail` if any severity=error issues found, `warn` if only severity=warning issues, `pass` if none.
- **Requirement 5**: Empty catch blocks and ignored Go errors are severity=error. Swallowed errors and bare except are severity=warning. Missing error handling (heuristic) is severity=warning.
- **Requirement 6**: Only scan files whose language is in the provided `languages` array.

---

## 2. The Truth (Executable Tests)

### 2.1 Acceptance Criteria (Gherkin)
```gherkin
Feature: Error Handling Pattern Detection

  Scenario: Detect empty catch block in TypeScript
    Given a file "src/service.ts" containing:
      """
      try {
        await fetch(url);
      } catch (err) {
      }
      """
    When I call checkErrorHandling with languages=["TypeScript"]
    Then the result contains an issue with pattern="Empty catch block" and severity="error"
    And the issue references file="src/service.ts"

  Scenario: Detect bare except in Python
    Given a file "app.py" containing:
      """
      try:
          process()
      except:
          pass
      """
    When I call checkErrorHandling with languages=["Python"]
    Then the result contains an issue with pattern="Bare except" and severity="warning"

  Scenario: Detect ignored error in Go
    Given a file "main.go" containing:
      """
      if err != nil {
      }
      """
    When I call checkErrorHandling with languages=["Go"]
    Then the result contains an issue with pattern="Ignored error" and severity="error"

  Scenario: Detect swallowed error in JavaScript
    Given a file "handler.js" containing:
      """
      try {
        doSomething();
      } catch (e) {
        console.log(e);
      }
      """
    When I call checkErrorHandling with languages=["JavaScript"]
    Then the result contains an issue with pattern="Swallowed error" and severity="warning"

  Scenario: No issues found
    Given a file "clean.ts" with proper error handling (try/catch with rethrow)
    When I call checkErrorHandling with languages=["TypeScript"]
    Then the result status is "pass" and issues array is empty

  Scenario: Skip files for languages not in filter
    Given a file "app.py" with bare except and languages=["TypeScript"]
    When I call checkErrorHandling
    Then "app.py" is not scanned and no Python issues appear
```

### 2.2 Verification Steps
- [ ] Empty catch blocks are detected in JS/TS/Java/C# files.
- [ ] Bare except blocks are detected in Python files.
- [ ] Ignored errors (`if err != nil {}`) are detected in Go files.
- [ ] Swallowed errors (catch with only console.log) are detected in JS/TS files.
- [ ] Missing error handling heuristic flags async functions without try/catch.
- [ ] Each issue has correct file path, line number, pattern name, and severity.
- [ ] Overall status correctly reflects the highest severity found.
- [ ] Language filter restricts which files are scanned.

---

## 3. The Implementation Guide (AI-to-AI)

### 3.1 Context & Files
- **Primary Files**: `src/server/analyzer/error-patterns.ts` (create)
- **Related Files**: `src/server/analyzer/languages/detector.ts` (reuse `EXTENSION_MAP`, `SKIP_DIRS`)
- **New Files Needed**:
  - `src/server/analyzer/error-patterns.ts`
  - `tests/analyzer/error-patterns.test.ts`

### 3.2 Technical Logic

**Step 1: Define types**

```typescript
// src/server/analyzer/error-patterns.ts

import { readFile, readdir } from 'node:fs/promises';
import { join, extname, relative } from 'node:path';
import { EXTENSION_MAP, SKIP_DIRS } from './languages/detector.js';

export type IssueSeverity = 'error' | 'warning';

export interface ErrorIssue {
  file: string;       // relative path
  line: number;       // 1-based line number
  pattern: string;    // human-readable pattern name
  severity: IssueSeverity;
  snippet?: string;   // the offending line (trimmed)
}

export interface ErrorPatternResult {
  status: 'pass' | 'warn' | 'fail';
  issues: ErrorIssue[];
  filesScanned: number;
}
```

**Step 2: Define pattern matchers per language**

```typescript
interface PatternDef {
  name: string;
  severity: IssueSeverity;
  // Returns array of { line, snippet } for each match found in the content
  detect: (content: string, lines: string[]) => Array<{ line: number; snippet: string }>;
}

const JS_TS_PATTERNS: PatternDef[] = [
  {
    name: 'Empty catch block',
    severity: 'error',
    detect: (content, lines) => {
      const results: Array<{ line: number; snippet: string }> = [];
      // Match catch(...) followed by empty braces (possibly with whitespace)
      const regex = /catch\s*\([^)]*\)\s*\{\s*\}/g;
      let match;
      while ((match = regex.exec(content)) !== null) {
        const line = content.substring(0, match.index).split('\n').length;
        results.push({ line, snippet: match[0].trim() });
      }
      return results;
    },
  },
  {
    name: 'Swallowed error',
    severity: 'warning',
    detect: (content, lines) => {
      const results: Array<{ line: number; snippet: string }> = [];
      // Find catch blocks where body only contains console.log/warn/error
      const regex = /catch\s*\([^)]*\)\s*\{([^}]*)\}/g;
      let match;
      while ((match = regex.exec(content)) !== null) {
        const body = match[1].trim();
        if (body === '') continue; // empty catch handled separately
        // Check if body only has console.* statements
        const bodyLines = body.split('\n').map(l => l.trim()).filter(l => l !== '');
        const allConsole = bodyLines.every(l =>
          /^console\.(log|warn|error|info)\(/.test(l)
        );
        if (allConsole && bodyLines.length > 0) {
          const line = content.substring(0, match.index).split('\n').length;
          results.push({ line, snippet: `catch block with only console output` });
        }
      }
      return results;
    },
  },
  {
    name: 'Missing error handling in async function',
    severity: 'warning',
    detect: (content, lines) => {
      const results: Array<{ line: number; snippet: string }> = [];
      // Find async functions, check if they contain try or .catch
      const regex = /async\s+function\s+(\w+)|(\w+)\s*=\s*async\s*\(/g;
      let match;
      while ((match = regex.exec(content)) !== null) {
        const fnName = match[1] || match[2];
        const startIdx = match.index;
        // Find function body by counting braces
        let braceStart = content.indexOf('{', startIdx);
        if (braceStart === -1) continue;
        let depth = 0;
        let endIdx = braceStart;
        for (let i = braceStart; i < content.length; i++) {
          if (content[i] === '{') depth++;
          if (content[i] === '}') depth--;
          if (depth === 0) { endIdx = i; break; }
        }
        const body = content.substring(braceStart, endIdx + 1);
        if (!body.includes('try') && !body.includes('.catch(')) {
          const line = content.substring(0, startIdx).split('\n').length;
          results.push({ line, snippet: `async function ${fnName} has no try/catch` });
        }
      }
      return results;
    },
  },
];

const PYTHON_PATTERNS: PatternDef[] = [
  {
    name: 'Bare except',
    severity: 'warning',
    detect: (content, lines) => {
      const results: Array<{ line: number; snippet: string }> = [];
      for (let i = 0; i < lines.length; i++) {
        if (/^\s*except\s*:\s*$/.test(lines[i])) {
          results.push({ line: i + 1, snippet: lines[i].trim() });
        }
      }
      return results;
    },
  },
];

const GO_PATTERNS: PatternDef[] = [
  {
    name: 'Ignored error',
    severity: 'error',
    detect: (content, lines) => {
      const results: Array<{ line: number; snippet: string }> = [];
      const regex = /if\s+err\s*!=\s*nil\s*\{\s*\}/g;
      let match;
      while ((match = regex.exec(content)) !== null) {
        const line = content.substring(0, match.index).split('\n').length;
        results.push({ line, snippet: match[0].trim() });
      }
      return results;
    },
  },
];

const JAVA_CS_PATTERNS: PatternDef[] = [
  {
    name: 'Empty catch block',
    severity: 'error',
    detect: (content, lines) => {
      const results: Array<{ line: number; snippet: string }> = [];
      const regex = /catch\s*\([^)]*\)\s*\{\s*\}/g;
      let match;
      while ((match = regex.exec(content)) !== null) {
        const line = content.substring(0, match.index).split('\n').length;
        results.push({ line, snippet: match[0].trim() });
      }
      return results;
    },
  },
];

const LANGUAGE_PATTERNS: Record<string, PatternDef[]> = {
  TypeScript: JS_TS_PATTERNS,
  JavaScript: JS_TS_PATTERNS,
  Python: PYTHON_PATTERNS,
  Go: GO_PATTERNS,
  Java: JAVA_CS_PATTERNS,
  'C#': JAVA_CS_PATTERNS,
  // Ruby and Rust: no specific patterns defined yet
};
```

**Step 3: Implement file scanning and pattern matching**

```typescript
async function collectSourceFilesForLanguages(
  dir: string,
  repoPath: string,
  languages: Set<string>,
  result: string[]
): Promise<void> {
  let entries;
  try {
    entries = await readdir(dir, { withFileTypes: true });
  } catch {
    return;
  }
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      if (!SKIP_DIRS.has(entry.name)) {
        await collectSourceFilesForLanguages(fullPath, repoPath, languages, result);
      }
    } else if (entry.isFile()) {
      const ext = extname(entry.name).toLowerCase();
      const lang = EXTENSION_MAP[ext];
      if (lang && languages.has(lang)) {
        result.push(fullPath);
      }
    }
  }
}

export async function checkErrorHandling(
  repoPath: string,
  languages: string[]
): Promise<ErrorPatternResult> {
  const langSet = new Set(languages);
  const filePaths: string[] = [];
  await collectSourceFilesForLanguages(repoPath, repoPath, langSet, filePaths);

  const issues: ErrorIssue[] = [];

  for (const filePath of filePaths) {
    const content = await readFile(filePath, 'utf-8');
    const lines = content.split('\n');
    const ext = extname(filePath).toLowerCase();
    const language = EXTENSION_MAP[ext];
    if (!language) continue;

    const patterns = LANGUAGE_PATTERNS[language];
    if (!patterns) continue;

    for (const pattern of patterns) {
      const matches = pattern.detect(content, lines);
      for (const match of matches) {
        issues.push({
          file: relative(repoPath, filePath),
          line: match.line,
          pattern: pattern.name,
          severity: pattern.severity,
          snippet: match.snippet,
        });
      }
    }
  }

  // Determine overall status
  let status: 'pass' | 'warn' | 'fail' = 'pass';
  if (issues.some(i => i.severity === 'error')) {
    status = 'fail';
  } else if (issues.some(i => i.severity === 'warning')) {
    status = 'warn';
  }

  return {
    status,
    issues,
    filesScanned: filePaths.length,
  };
}
```

### 3.3 API Contract
N/A — this is an internal module consumed by the analysis engine (STORY-005-08). No HTTP endpoints.

---

## 4. Definition of Done (The Gate)
- [ ] `src/server/analyzer/error-patterns.ts` exists and exports `checkErrorHandling` and all related types.
- [ ] Empty catch blocks are detected in JS/TS/Java/C# files with severity=error.
- [ ] Bare except is detected in Python files with severity=warning.
- [ ] Ignored errors (`if err != nil {}`) are detected in Go files with severity=error.
- [ ] Swallowed errors (catch with only console.log) are detected in JS/TS with severity=warning.
- [ ] Missing error handling heuristic works for async functions in JS/TS.
- [ ] Each issue includes file path, line number, pattern name, severity, and snippet.
- [ ] Overall status reflects highest severity: fail > warn > pass.
- [ ] Language filter correctly restricts which files are scanned.
- [ ] Unit tests pass covering all pattern types and edge cases.
- [ ] No TypeScript compilation errors (`npx tsc --noEmit`).
